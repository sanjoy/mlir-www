<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Utils/Utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_36ccfdf0d236a67fd57e73c4a5bad479.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BlockAndValueMapping_8h_source.html">mlir/IR/BlockAndValueMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Utils.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="Dialect_2Affine_2Utils_2Utils_8cpp__incl.png" border="0" usemap="#lib_2Dialect_2Affine_2Utils_2Utils_8cpp" alt=""/></div>
<map name="lib_2Dialect_2Affine_2Utils_2Utils_8cpp" id="lib_2Dialect_2Affine_2Utils_2Utils_8cpp">
<area shape="rect" id="node2" href="Dialect_2Affine_2Utils_8h.html" title="mlir/Dialect/Affine\l/Utils.h" alt="" coords="970,95,1110,136"/>
<area shape="rect" id="node20" href="Dialect_2Affine_2Analysis_2Utils_8h.html" title="mlir/Dialect/Affine\l/Analysis/Utils.h" alt="" coords="289,363,429,404"/>
<area shape="rect" id="node31" href="AffineOps_8h.html" title="mlir/Dialect/Affine\l/IR/AffineOps.h" alt="" coords="2051,184,2191,225"/>
<area shape="rect" id="node36" href="AffineValueMap_8h.html" title="mlir/Dialect/Affine\l/IR/AffineValueMap.h" alt="" coords="2398,452,2554,493"/>
<area shape="rect" id="node37" href="LoopUtils_8h.html" title="mlir/Dialect/Affine\l/LoopUtils.h" alt="" coords="2506,363,2646,404"/>
<area shape="rect" id="node38" href="MemRef_8h.html" title="mlir/Dialect/MemRef\l/IR/MemRef.h" alt="" coords="1499,273,1653,315"/>
<area shape="rect" id="node44" href="BlockAndValueMapping_8h.html" title="mlir/IR/BlockAndValueMapping.h" alt="" coords="2305,102,2538,129"/>
<area shape="rect" id="node45" href="Dominance_8h.html" title="mlir/IR/Dominance.h" alt="" coords="2701,102,2856,129"/>
<area shape="rect" id="node48" href="IR_2IntegerSet_8h.html" title="mlir/IR/IntegerSet.h" alt="" coords="2027,549,2175,575"/>
<area shape="rect" id="node49" href="GreedyPatternRewriteDriver_8h.html" title="mlir/Transforms/GreedyPattern\lRewriteDriver.h" alt="" coords="3191,95,3412,136"/>
<area shape="rect" id="node3" href="AffineAnalysis_8h.html" title="mlir/Dialect/Affine\l/Analysis/AffineAnalysis.h" alt="" coords="575,184,766,225"/>
<area shape="rect" id="node4" href="Arithmetic_8h.html" title="mlir/Dialect/Arithmetic\l/IR/Arithmetic.h" alt="" coords="672,363,843,404"/>
<area shape="rect" id="node8" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="1621,877,1739,903"/>
<area shape="rect" id="node15" href="Ops_8h.html" title="mlir/Dialect/StandardOps\l/IR/Ops.h" alt="" coords="817,273,1002,315"/>
<area shape="rect" id="node5" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="1139,638,1266,665"/>
<area shape="rect" id="node12" href="OpDefinition_8h.html" title="mlir/IR/OpDefinition.h" alt="" coords="1121,549,1284,575"/>
<area shape="rect" id="node13" href="CastInterfaces_8h.html" title="mlir/Interfaces/CastInterfaces.h" alt="" coords="1085,459,1312,486"/>
<area shape="rect" id="node14" href="SideEffectInterfaces_8h.html" title="mlir/Interfaces/SideEffect\lInterfaces.h" alt="" coords="875,452,1061,493"/>
<area shape="rect" id="node6" href="OperationSupport_8h.html" title="mlir/IR/OperationSupport.h" alt="" coords="1697,720,1892,747"/>
<area shape="rect" id="node7" href="BlockSupport_8h.html" title="mlir/IR/BlockSupport.h" alt="" coords="1718,795,1885,821"/>
<area shape="rect" id="node10" href="Location_8h.html" title="mlir/IR/Location.h" alt="" coords="87,795,223,821"/>
<area shape="rect" id="node9" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="698,959,849,985"/>
<area shape="rect" id="node16" href="CallInterfaces_8h.html" title="mlir/Interfaces/CallInterfaces.h" alt="" coords="967,370,1190,397"/>
<area shape="rect" id="node17" href="ControlFlowInterfaces_8h.html" title="mlir/Interfaces/ControlFlow\lInterfaces.h" alt="" coords="1214,363,1413,404"/>
<area shape="rect" id="node21" href="AffineStructures_8h.html" title="mlir/Dialect/Affine\l/Analysis/AffineStructures.h" alt="" coords="94,452,295,493"/>
<area shape="rect" id="node28" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="1856,549,2003,575"/>
<area shape="rect" id="node30" href="Block_8h.html" title="mlir/IR/Block.h" alt="" coords="2155,459,2272,486"/>
<area shape="rect" id="node22" href="IntegerPolyhedron_8h.html" title="mlir/Analysis/Presburger\l/IntegerPolyhedron.h" alt="" coords="232,541,413,583"/>
<area shape="rect" id="node23" href="Matrix_8h.html" title="mlir/Analysis/Presburger\l/Matrix.h" alt="" coords="365,631,547,672"/>
<area shape="rect" id="node25" href="LogicalResult_8h.html" title="mlir/Support/LogicalResult.h" alt="" coords="137,638,341,665"/>
<area shape="rect" id="node26" href="IR_2AffineExpr_8h.html" title="mlir/IR/AffineExpr.h" alt="" coords="1595,638,1741,665"/>
<area shape="rect" id="node32" href="AffineMemoryOpInterfaces_8h.html" title="mlir/Dialect/Affine\l/IR/AffineMemoryOpInterfaces.h" alt="" coords="1815,452,2044,493"/>
<area shape="rect" id="node33" href="LoopLikeInterface_8h.html" title="mlir/Interfaces/LoopLike\lInterface.h" alt="" coords="1775,273,1953,315"/>
<area shape="rect" id="node39" href="ReshapeOpsUtils_8h.html" title="mlir/Dialect/Utils\l/ReshapeOpsUtils.h" alt="" coords="603,869,751,911"/>
<area shape="rect" id="node40" href="CopyOpInterface_8h.html" title="mlir/Interfaces/CopyOpInterface.h" alt="" coords="1387,459,1629,486"/>
<area shape="rect" id="node41" href="ViewLikeInterface_8h.html" title="mlir/Interfaces/ViewLike\lInterface.h" alt="" coords="1639,363,1819,404"/>
<area shape="rect" id="node46" href="RegionGraphTraits_8h.html" title="mlir/IR/RegionGraphTraits.h" alt="" coords="2918,191,3117,218"/>
<area shape="rect" id="node50" href="FrozenRewritePatternSet_8h.html" title="mlir/Rewrite/FrozenRewrite\lPatternSet.h" alt="" coords="3203,184,3399,225"/>
</map>
</div>
</div>
<p><a href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-utils&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8361db875ebdd069691084e31cb1f90a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> { <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6">TileFloorDiv</a>, 
<a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec">TileMod</a>, 
<a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e">TileNone</a>
 }<tr class="memdesc:a8361db875ebdd069691084e31cb1f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to set patterns of affine expr in tiled-layout map.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8361db875ebdd069691084e31cb1f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91ed5c48cf2d60834e274223a2fe3391"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a91ed5c48cf2d60834e274223a2fe3391">promoteIfBlock</a> (AffineIfOp ifOp, bool elseBlock)</td></tr>
<tr class="memdesc:a91ed5c48cf2d60834e274223a2fe3391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>then</code> or the <code>else</code> block of <code>ifOp</code> (depending on whether <code>elseBlock</code> is false or true) into <code>ifOp</code>'s containing block, and discards the rest of the op.  <a href="#a91ed5c48cf2d60834e274223a2fe3391">More...</a><br /></td></tr>
<tr class="separator:a91ed5c48cf2d60834e274223a2fe3391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c58877969ba751da8da214b1866e2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ac0c58877969ba751da8da214b1866e2e">getOutermostInvariantForOp</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:ac0c58877969ba751da8da214b1866e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outermost affine.for/parallel op that the <code>ifOp</code> is invariant on.  <a href="#ac0c58877969ba751da8da214b1866e2e">More...</a><br /></td></tr>
<tr class="separator:ac0c58877969ba751da8da214b1866e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3327936fe7d848e7ec99d8efaebf3794"><td class="memItemLeft" align="right" valign="top">static AffineIfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a3327936fe7d848e7ec99d8efaebf3794">hoistAffineIfOp</a> (AffineIfOp ifOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *hoistOverOp)</td></tr>
<tr class="memdesc:a3327936fe7d848e7ec99d8efaebf3794"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for the mechanics of <a class="el" href="namespacemlir.html#a57bafa91f432ad40bb6246fbcbd555fe" title="Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel&#39;s. ">mlir::hoistAffineIfOp</a>.  <a href="#a3327936fe7d848e7ec99d8efaebf3794">More...</a><br /></td></tr>
<tr class="separator:a3327936fe7d848e7ec99d8efaebf3794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4179d402ef316fbb0be21b2f38c127"><td class="memTemplParams" colspan="2">template&lt;typename EffectType , typename T &gt; </td></tr>
<tr class="memitem:a2b4179d402ef316fbb0be21b2f38c127"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a2b4179d402ef316fbb0be21b2f38c127">hasNoInterveningEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *start, T memOp)</td></tr>
<tr class="memdesc:a2b4179d402ef316fbb0be21b2f38c127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all operations that could be executed after <code>start</code> (noninclusive) and prior to <code>memOp</code> (e.g.  <a href="#a2b4179d402ef316fbb0be21b2f38c127">More...</a><br /></td></tr>
<tr class="separator:a2b4179d402ef316fbb0be21b2f38c127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e60919d99d557f35d9f6b2b1a05b38"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ae2e60919d99d557f35d9f6b2b1a05b38">forwardStoreToLoad</a> (<a class="el" href="classmlir_1_1AffineReadOpInterface.html">AffineReadOpInterface</a> loadOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;loadOpsToErase, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="memdesc:ae2e60919d99d557f35d9f6b2b1a05b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve.  <a href="#ae2e60919d99d557f35d9f6b2b1a05b38">More...</a><br /></td></tr>
<tr class="separator:ae2e60919d99d557f35d9f6b2b1a05b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26497ef59e96949344ad5f762c83b2ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a26497ef59e96949344ad5f762c83b2ff">findUnusedStore</a> (<a class="el" href="classmlir_1_1AffineWriteOpInterface.html">AffineWriteOpInterface</a> writeA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;opsToErase, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefsToErase, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDominanceInfo)</td></tr>
<tr class="separator:a26497ef59e96949344ad5f762c83b2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265ee9bd7371fa494b507000eba68114"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a265ee9bd7371fa494b507000eba68114">loadCSE</a> (<a class="el" href="classmlir_1_1AffineReadOpInterface.html">AffineReadOpInterface</a> loadA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;loadOpsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="separator:a265ee9bd7371fa494b507000eba68114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cf0842c1c6bce487e9c42d7593543"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543">getTileSizePos</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt; &amp;tileSizePos)</td></tr>
<tr class="memdesc:a533cf0842c1c6bce487e9c42d7593543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>map</code> is a tiled layout.  <a href="#a533cf0842c1c6bce487e9c42d7593543">More...</a><br /></td></tr>
<tr class="separator:a533cf0842c1c6bce487e9c42d7593543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb08d5234d99d6f4af63a5d0466028d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8">isNormalizedMemRefDynamicDim</a> (<a class="el" href="classunsigned.html">unsigned</a> dim, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> layoutMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;inMemrefTypeDynDims, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:adb08d5234d99d6f4af63a5d0466028d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>dim</code> dimension of memrefType with <code>layoutMap</code> becomes dynamic after normalization.  <a href="#adb08d5234d99d6f4af63a5d0466028d8">More...</a><br /></td></tr>
<tr class="separator:adb08d5234d99d6f4af63a5d0466028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108">createDimSizeExprForTiledLayout</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> oldMapOutput, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> pat)</td></tr>
<tr class="memdesc:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create affine expr to calculate dimension size for a tiled-layout map.  <a href="#ab1d1fa11b6b2534b14e10e5214f5a108">More...</a><br /></td></tr>
<tr class="separator:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01de90caeccd203207a3806b7dae0ba3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a01de90caeccd203207a3806b7dae0ba3">createNewDynamicSizes</a> (MemRefType oldMemRefType, MemRefType newMemRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, memref::AllocOp *allocOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newDynamicSizes)</td></tr>
<tr class="memdesc:a01de90caeccd203207a3806b7dae0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new maps to calculate each dimension size of <code>newMemRefType</code>, and create <code>newDynamicSizes</code> from them by using AffineApplyOp.  <a href="#a01de90caeccd203207a3806b7dae0ba3">More...</a><br /></td></tr>
<tr class="separator:a01de90caeccd203207a3806b7dae0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00026">26</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8361db875ebdd069691084e31cb1f90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8361db875ebdd069691084e31cb1f90a">&#9670;&nbsp;</a></span>TileExprPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to set patterns of affine expr in tiled-layout map. </p>
<p>TileFloorDiv: &lt;dim expr&gt;=""&gt; div &lt;tile size&gt;=""&gt; TileMod: &lt;dim expr&gt;=""&gt; mod &lt;tile size&gt;=""&gt; TileNone: None of the above Example: #tiled_2d_128x256 = affine_map&lt;(d0, d1) -&gt; (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)&gt; "d0 div 128" and "d1 div 256" ==&gt; TileFloorDiv "d0 mod 128" and "d1 mod 256" ==&gt; TileMod </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6"></a>TileFloorDiv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec"></a>TileMod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e"></a>TileNone&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01232">1232</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab1d1fa11b6b2534b14e10e5214f5a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1fa11b6b2534b14e10e5214f5a108">&#9670;&nbsp;</a></span>createDimSizeExprForTiledLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> createDimSizeExprForTiledLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>oldMapOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a>&#160;</td>
          <td class="paramname"><em>pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create affine expr to calculate dimension size for a tiled-layout map. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01359">1359</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">mlir::CeilDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00045">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00304">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00307">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01232">TileFloorDiv</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01232">TileMod</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01414">createNewDynamicSizes()</a>.</p>

</div>
</div>
<a id="a01de90caeccd203207a3806b7dae0ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01de90caeccd203207a3806b7dae0ba3">&#9670;&nbsp;</a></span>createNewDynamicSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> createNewDynamicSizes </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>oldMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>newMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp *&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newDynamicSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new maps to calculate each dimension size of <code>newMemRefType</code>, and create <code>newDynamicSizes</code> from them by using AffineApplyOp. </p>
<p>Steps for normalizing dynamic memrefs for a tiled layout map Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt; %0 = dim arg0, c1 :memref&lt;4x?xf32&gt; %1 = alloc(%0) : memref&lt;4x?xf32, #map0&gt;</p>
<p>(Before this function)</p><ol type="1">
<li>Check if <code>map</code>(#map0) is a tiled layout using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543" title="Check if map is a tiled layout. ">getTileSizePos()</a></code>. Only single layout map is supported.</li>
<li>Create normalized memrefType using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8" title="Check if dim dimension of memrefType with layoutMap becomes dynamic after normalization. ">isNormalizedMemRefDynamicDim()</a></code>. It is memref&lt;4x?x?xf32&gt; in the above example.</li>
</ol>
<p>(In this function)</p><ol type="1">
<li>Create new maps to calculate each dimension of the normalized memrefType using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108" title="Create affine expr to calculate dimension size for a tiled-layout map. ">createDimSizeExprForTiledLayout()</a></code>. In the tiled layout, the dimension size can be calculated by replacing "floordiv &lt;tile size&gt;" with "ceildiv &lt;tile size&gt;" and "mod &lt;tile size&gt;" with "&lt;tile size&gt;".</li>
</ol>
<ul>
<li>New map in the above example #map0 = affine_map&lt;(d0, d1) -&gt; (d0)&gt; #map1 = affine_map&lt;(d0, d1) -&gt; (d1 ceildiv 32)&gt; #map2 = affine_map&lt;(d0, d1) -&gt; (32)&gt;</li>
</ul>
<ol type="1">
<li>Create AffineApplyOp to apply the new maps. The output of AffineApplyOp is used in dynamicSizes of new AllocOp. %0 = dim arg0, c1 : memref&lt;4x?xf32&gt; c4 = arith.constant 4 : index %1 = affine.apply #map1(c4, %0) %2 = affine.apply #map2(c4, %0) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01414">1414</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01359">createDimSizeExprForTiledLayout()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00961">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00048">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00170">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01240">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01232">TileFloorDiv</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01232">TileMod</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01232">TileNone</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01464">mlir::normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a26497ef59e96949344ad5f762c83b2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26497ef59e96949344ad5f762c83b2ff">&#9670;&nbsp;</a></span>findUnusedStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> findUnusedStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineWriteOpInterface.html">AffineWriteOpInterface</a>&#160;</td>
          <td class="paramname"><em>writeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>opsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memrefsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>postDominanceInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00685">685</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AffineWriteOpInterface.html#a2fab3b6e91539f8e7c95428fd0352fce">mlir::AffineWriteOpInterface::getMemRef()</a>, <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUsers()</a>, and <a class="el" href="Dominance_8h_source.html#l00184">mlir::PostDominanceInfo::postDominates()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00811">mlir::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="ae2e60919d99d557f35d9f6b2b1a05b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e60919d99d557f35d9f6b2b1a05b38">&#9670;&nbsp;</a></span>forwardStoreToLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> forwardStoreToLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineReadOpInterface.html">AffineReadOpInterface</a>&#160;</td>
          <td class="paramname"><em>loadOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOpsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memrefsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve. </p>
<p>This check involves three components: 1) The store and load must be on the same location 2) The store must dominate (and therefore must always occur prior to) the load 3) No other operations will overwrite the memory loaded between the given load and store. If such a value exists, the replaced <code>loadOp</code> will be added to <code>loadOpsToErase</code> and its memref will be added to <code>memrefsToErase</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00621">621</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00137">mlir::DominanceInfo::dominates()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#a8244a4feee85f6bd09a2c68ea316572d">mlir::AffineReadOpInterface::getMemRef()</a>, <a class="el" href="Value_8h_source.html#l00117">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUsers()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#ab0b307ac79e93d7e8f37814e59c8ef23">mlir::AffineReadOpInterface::getValue()</a>, <a class="el" href="Value_8h_source.html#l00161">mlir::Value::replaceAllUsesWith()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00811">mlir::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="ac0c58877969ba751da8da214b1866e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c58877969ba751da8da214b1866e2e">&#9670;&nbsp;</a></span>getOutermostInvariantForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* getOutermostInvariantForOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outermost affine.for/parallel op that the <code>ifOp</code> is invariant on. </p>
<p>The <code>ifOp</code> could be hoisted and placed right before such an operation. This method assumes that the ifOp has been canonicalized (to be correct and effective). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00049">49</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00247">mlir::Operation::getOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00198">mlir::hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a533cf0842c1c6bce487e9c42d7593543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533cf0842c1c6bce487e9c42d7593543">&#9670;&nbsp;</a></span>getTileSizePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> getTileSizePos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tileSizePos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>map</code> is a tiled layout. </p>
<p>In the tiled layout, specific k dimensions being floordiv'ed by respective tile sizes appeare in a mod with the same tile sizes, and no other expression involves those k dimensions. This function stores a vector of tuples (<code>tileSizePos</code>) including AffineExpr for tile size, positions of corresponding <code>floordiv</code> and <code>mod</code>. If it is not a tiled layout, an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01240">1240</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">mlir::FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00304">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00307">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">mlir::Mod</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01414">createNewDynamicSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01464">mlir::normalizeMemRef()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01522">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a2b4179d402ef316fbb0be21b2f38c127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4179d402ef316fbb0be21b2f38c127">&#9670;&nbsp;</a></span>hasNoInterveningEffect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectType , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasNoInterveningEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>memOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that all operations that could be executed after <code>start</code> (noninclusive) and prior to <code>memOp</code> (e.g. </p>
<p>on a control flow/op path between the operations) do not have the potential memory effect <code>EffectType</code> on <code>memOp</code>. <code>memOp</code> is an operation that reads or writes to a memref. For example, if <code>EffectType</code> is MemoryEffects::Write, this method will check if there is no write to the memory between <code>start</code> and <code>memOp</code> that would change the read within <code>memOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00447">447</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00568">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="Operation_8h_source.html#l00096">mlir::Operation::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01280">mlir::getNumCommonSurroundingLoops()</a>, <a class="el" href="Operation_8h_source.html#l00117">mlir::Operation::getParentOp()</a>, <a class="el" href="Operation_8h_source.html#l00113">mlir::Operation::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="Block_8h_source.html#l00255">mlir::Block::getSuccessors()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00175">mlir::hasDependence()</a>, <a class="el" href="Operation_8h_source.html#l00145">mlir::Operation::isAncestor()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00080">mlir::MemRefAccess::memref</a>.</p>

</div>
</div>
<a id="a3327936fe7d848e7ec99d8efaebf3794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3327936fe7d848e7ec99d8efaebf3794">&#9670;&nbsp;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineIfOp hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>hoistOverOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for the mechanics of <a class="el" href="namespacemlir.html#a57bafa91f432ad40bb6246fbcbd555fe" title="Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel&#39;s. ">mlir::hoistAffineIfOp</a>. </p>
<p>Hoists <code>ifOp</code> just over <code>hoistOverOp</code>. Returns the new hoisted op if any hoisting happened, otherwise the same <code>ifOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00075">75</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00073">mlir::BlockAndValueMapping::clear()</a>, <a class="el" href="Builders_8cpp_source.html#l00457">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="Operation_8h_source.html#l00096">mlir::Operation::getBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00087">mlir::Builder::getBoolAttr()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>, <a class="el" href="Builders_8cpp_source.html#l00201">mlir::Builder::getStringAttr()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00033">promoteIfBlock()</a>, and <a class="el" href="Builders_8h_source.html#l00343">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="adb08d5234d99d6f4af63a5d0466028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb08d5234d99d6f4af63a5d0466028d8">&#9670;&nbsp;</a></span>isNormalizedMemRefDynamicDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isNormalizedMemRefDynamicDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>layoutMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inMemrefTypeDynDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>dim</code> dimension of memrefType with <code>layoutMap</code> becomes dynamic after normalization. </p>
<p>Dimensions that include dynamic dimensions in the map output will become dynamic dimensions. Return true if <code>dim</code> is dynamic dimension.</p>
<p>Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt;</p>
<p>If d1 is dynamic dimension, 2nd and 3rd dimension of map output are dynamic. memref&lt;4x?xf32, #map0&gt; ==&gt; memref&lt;4x?x?xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01339">1339</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00028">mlir::AffineExpr::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01522">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a265ee9bd7371fa494b507000eba68114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265ee9bd7371fa494b507000eba68114">&#9670;&nbsp;</a></span>loadCSE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> loadCSE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineReadOpInterface.html">AffineReadOpInterface</a>&#160;</td>
          <td class="paramname"><em>loadA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOpsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00731">731</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00137">mlir::DominanceInfo::dominates()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#a8244a4feee85f6bd09a2c68ea316572d">mlir::AffineReadOpInterface::getMemRef()</a>, <a class="el" href="OpDefinition_8h_source.html#l00106">mlir::OpState::getOperation()</a>, <a class="el" href="Value_8h_source.html#l00117">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUsers()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#ab0b307ac79e93d7e8f37814e59c8ef23">mlir::AffineReadOpInterface::getValue()</a>, and <a class="el" href="Value_8h_source.html#l00161">mlir::Value::replaceAllUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00811">mlir::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a91ed5c48cf2d60834e274223a2fe3391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed5c48cf2d60834e274223a2fe3391">&#9670;&nbsp;</a></span>promoteIfBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> promoteIfBlock </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>elseBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promotes the <code>then</code> or the <code>else</code> block of <code>ifOp</code> (depending on whether <code>elseBlock</code> is false or true) into <code>ifOp</code>'s containing block, and discards the rest of the op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00033">33</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, and <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00075">hoistAffineIfOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 26 2022 20:34:15 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
