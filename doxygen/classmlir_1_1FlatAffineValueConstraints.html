<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::FlatAffineValueConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmlir_1_1FlatAffineValueConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineValueConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An extension of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> in which dimensions and symbols can optionally be associated with an SSA value.  
 <a href="classmlir_1_1FlatAffineValueConstraints.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::FlatAffineValueConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__inherit__graph.png" border="0" usemap="#mlir_1_1FlatAffineValueConstraints_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1FlatAffineValueConstraints_inherit__map" id="mlir_1_1FlatAffineValueConstraints_inherit__map">
<area shape="rect" id="node4" href="classmlir_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain &#45;&gt; range) where &quot;domain&quot; and &quot;range&quot; a..." alt="" coords="34,229,205,256"/>
<area shape="rect" id="node2" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. " alt="" coords="23,80,215,107"/>
<area shape="rect" id="node3" href="classmlir_1_1IntegerPolyhedron.html" title="An integer polyhedron is the set of solutions to a list of affine constraints over n integer&#45;valued v..." alt="" coords="32,5,207,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::FlatAffineValueConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__coll__graph.png" border="0" usemap="#mlir_1_1FlatAffineValueConstraints_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1FlatAffineValueConstraints_coll__map" id="mlir_1_1FlatAffineValueConstraints_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. " alt="" coords="14,272,206,299"/>
<area shape="rect" id="node3" href="classmlir_1_1IntegerPolyhedron.html" title="An integer polyhedron is the set of solutions to a list of affine constraints over n integer&#45;valued v..." alt="" coords="23,146,197,173"/>
<area shape="rect" id="node4" href="classmlir_1_1Matrix.html" title="This is a class to represent a resizable matrix. " alt="" coords="5,5,103,32"/>
<area shape="rect" id="node5" href="classunsigned.html" title="unsigned" alt="" coords="127,5,208,32"/>
<area shape="rect" id="node6" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l llvm::Optional\&lt; mlir\l::Value \&gt;, 8 \&gt;" alt="" coords="231,257,389,313"/>
<area shape="rect" id="node7" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l T, N \&gt;" alt="" coords="236,139,384,180"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aaec51cfb6129c7a10dbf24740897cf1b">FlatAffineValueConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:aaec51cfb6129c7a10dbf24740897cf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="#aaec51cfb6129c7a10dbf24740897cf1b">More...</a><br /></td></tr>
<tr class="separator:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a8ba51af6e35a94b11d73b5215a35ff7a">FlatAffineValueConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="#a8ba51af6e35a94b11d73b5215a35ff7a">More...</a><br /></td></tr>
<tr class="separator:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac652e97cab7cf64e3bef1b3418692a2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac652e97cab7cf64e3bef1b3418692a2a">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;fac, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="separator:ac652e97cab7cf64e3bef1b3418692a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af048f5fb19968688b331c7bb0f8d9a4d">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;avm)</td></tr>
<tr class="memdesc:af048f5fb19968688b331c7bb0f8d9a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these.  <a href="#af048f5fb19968688b331c7bb0f8d9a4d">More...</a><br /></td></tr>
<tr class="separator:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa32c847534d57cff25fdfa654778e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a0aa32c847534d57cff25fdfa654778e0">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef)</td></tr>
<tr class="separator:a0aa32c847534d57cff25fdfa654778e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa812729dd90454f1c10517520dde9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3fa812729dd90454f1c10517520dde9a">FlatAffineValueConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a3fa812729dd90454f1c10517520dde9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="#a3fa812729dd90454f1c10517520dde9a">More...</a><br /></td></tr>
<tr class="separator:a3fa812729dd90454f1c10517520dde9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a948d12b8760154eed1281249b0f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4c5a948d12b8760154eed1281249b0f7">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="separator:a4c5a948d12b8760154eed1281249b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac6234845a4fa3eb9444e56cab0fe5b0e">getKind</a> () const override</td></tr>
<tr class="memdesc:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kind of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">More...</a><br /></td></tr>
<tr class="separator:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9813ab39fe84ac3208f6475c0058e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad9813ab39fe84ac3208f6475c0058e02">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0) override</td></tr>
<tr class="memdesc:ad9813ab39fe84ac3208f6475c0058e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any existing data and reserves memory for the specified constraints.  <a href="#ad9813ab39fe84ac3208f6475c0058e02">More...</a><br /></td></tr>
<tr class="separator:ad9813ab39fe84ac3208f6475c0058e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00fa2f257f1bd2c8ab11369207198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a58e00fa2f257f1bd2c8ab11369207198">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:a58e00fa2f257f1bd2c8ab11369207198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a94ce5a825b81e5767fef38db2329a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae3a94ce5a825b81e5767fef38db2329a">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:ae3a94ce5a825b81e5767fef38db2329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592860df144ae17907bccf79792e3f90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a592860df144ae17907bccf79792e3f90">clone</a> () const</td></tr>
<tr class="memdesc:a592860df144ae17907bccf79792e3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this object.  <a href="#a592860df144ae17907bccf79792e3f90">More...</a><br /></td></tr>
<tr class="separator:a592860df144ae17907bccf79792e3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85192d2ad28e90993950ec5c2598a3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a85192d2ad28e90993950ec5c2598a3e7">addAffineForOpDomain</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a85192d2ad28e90993950ec5c2598a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps.  <a href="#a85192d2ad28e90993950ec5c2598a3e7">More...</a><br /></td></tr>
<tr class="separator:a85192d2ad28e90993950ec5c2598a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4287995c9f074be38e7e1d76b39d93f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4287995c9f074be38e7e1d76b39d93f8">addDomainFromSliceMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a4287995c9f074be38e7e1d76b39d93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice.  <a href="#a4287995c9f074be38e7e1d76b39d93f8">More...</a><br /></td></tr>
<tr class="separator:a4287995c9f074be38e7e1d76b39d93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1b74b3973d5329fe7ec99a7d2f8ed31f">addAffineIfOpDomain</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints imposed by the <code>affine.if</code> operation.  <a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">More...</a><br /></td></tr>
<tr class="separator:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae0266a236d1adc4c4a08e4d68b741e38">addBound</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae0266a236d1adc4c4a08e4d68b741e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands.  <a href="#ae0266a236d1adc4c4a08e4d68b741e38">More...</a><br /></td></tr>
<tr class="separator:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210341fc77fde46aedce6d2609f26738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a210341fc77fde46aedce6d2609f26738">addBound</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a210341fc77fde46aedce6d2609f26738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the identifier associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a210341fc77fde46aedce6d2609f26738">More...</a><br /></td></tr>
<tr class="separator:a210341fc77fde46aedce6d2609f26738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dbadcb953c32567a17ab1b662505e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac0dbadcb953c32567a17ab1b662505e0">getIneqAsAffineValueMap</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> ineqPos, <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;vmap, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ac0dbadcb953c32567a17ab1b662505e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bound for the identifier at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands).  <a href="#ac0dbadcb953c32567a17ab1b662505e0">More...</a><br /></td></tr>
<tr class="separator:ac0dbadcb953c32567a17ab1b662505e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad38a7dd065a6c286b7ac84f0d1712c23">addSliceBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each identifier in the constraint system which has a value in <code>values</code>.  <a href="#ad38a7dd065a6c286b7ac84f0d1712c23">More...</a><br /></td></tr>
<tr class="separator:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab578264c931fe0f78eb0397943d032c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ab578264c931fe0f78eb0397943d032c1">findId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classunsigned.html">unsigned</a> *pos) const</td></tr>
<tr class="memdesc:ab578264c931fe0f78eb0397943d032c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#ab578264c931fe0f78eb0397943d032c1">More...</a><br /></td></tr>
<tr class="separator:ab578264c931fe0f78eb0397943d032c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9d547b7f44aaa82af5d5ab1aeb74a42a">containsId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val) const</td></tr>
<tr class="memdesc:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise.  <a href="#a9d547b7f44aaa82af5d5ab1aeb74a42a">More...</a><br /></td></tr>
<tr class="separator:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda87dfc4340eb857e9bc9ab05141b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acda87dfc4340eb857e9bc9ab05141b16">swapId</a> (<a class="el" href="classunsigned.html">unsigned</a> posA, <a class="el" href="classunsigned.html">unsigned</a> posB) override</td></tr>
<tr class="memdesc:acda87dfc4340eb857e9bc9ab05141b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the posA^th identifier with the posB^th identifier.  <a href="#acda87dfc4340eb857e9bc9ab05141b16">More...</a><br /></td></tr>
<tr class="separator:acda87dfc4340eb857e9bc9ab05141b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37618dd64a6fe91226805818e4139fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a37618dd64a6fe91226805818e4139fb9">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="memdesc:a37618dd64a6fe91226805818e4139fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert identifiers of the specified kind at position <code>pos</code>.  <a href="#a37618dd64a6fe91226805818e4139fb9">More...</a><br /></td></tr>
<tr class="separator:a37618dd64a6fe91226805818e4139fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c6ee75c0627beaeb455d0428636849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a99c6ee75c0627beaeb455d0428636849">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a99c6ee75c0627beaeb455d0428636849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dde72b54f749643d4002efc28a643a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a7dde72b54f749643d4002efc28a643a0">insertId</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1) override</td></tr>
<tr class="separator:a7dde72b54f749643d4002efc28a643a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a31a532a6942ad1f960d6663ab8fede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5a31a532a6942ad1f960d6663ab8fede">insertId</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a5a31a532a6942ad1f960d6663ab8fede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a18111fe7ef555fcb69a9d6a175ea8cd8">appendDimId</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="memdesc:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append identifiers of the specified kind after the last identifier of that kind.  <a href="#a18111fe7ef555fcb69a9d6a175ea8cd8">More...</a><br /></td></tr>
<tr class="separator:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a6f8c373783c6b808038d8c07e796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2c2a6f8c373783c6b808038d8c07e796">appendSymbolId</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a2c2a6f8c373783c6b808038d8c07e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150883739ccac33efedf30dd36decfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1150883739ccac33efedf30dd36decfb">addInductionVarOrTerminalSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a1150883739ccac33efedf30dd36decfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system.  <a href="#a1150883739ccac33efedf30dd36decfb">More...</a><br /></td></tr>
<tr class="separator:a1150883739ccac33efedf30dd36decfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1918c91299c463de63c843ee1f7628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5f1918c91299c463de63c843ee1f7628">computeAlignedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands) const</td></tr>
<tr class="memdesc:a5f1918c91299c463de63c843ee1f7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>map</code> with this constraint system based on <code>operands</code>.  <a href="#a5f1918c91299c463de63c843ee1f7628">More...</a><br /></td></tr>
<tr class="separator:a5f1918c91299c463de63c843ee1f7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad4dd23a785eb9a02c7f2ba43fa1aa7db">composeMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *vMap)</td></tr>
<tr class="memdesc:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map.  <a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">More...</a><br /></td></tr>
<tr class="separator:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a79575e2c2693576f2c5a4accf0dcdab6">projectOut</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a79575e2c2693576f2c5a4accf0dcdab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a79575e2c2693576f2c5a4accf0dcdab6">More...</a><br /></td></tr>
<tr class="separator:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b004fb4978436d8c8cd8976803468c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a38b004fb4978436d8c8cd8976803468c">convertLoopIVSymbolsToDims</a> ()</td></tr>
<tr class="memdesc:a38b004fb4978436d8c8cd8976803468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all symbol identifiers which are loop IVs to dim identifiers.  <a href="#a38b004fb4978436d8c8cd8976803468c">More...</a><br /></td></tr>
<tr class="separator:a38b004fb4978436d8c8cd8976803468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af0c35f1d2d81adf4ba06b84df578cd78">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:af0c35f1d2d81adf4ba06b84df578cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="#af0c35f1d2d81adf4ba06b84df578cd78">More...</a><br /></td></tr>
<tr class="separator:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eed02898a13f56e0bc2a470c2f89af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad2eed02898a13f56e0bc2a470c2f89af">mergeAndAlignIdsWithOther</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *other)</td></tr>
<tr class="memdesc:ad2eed02898a13f56e0bc2a470c2f89af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align the identifiers of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with <code>this</code>'s original identifiers appearing first followed by any of <code>other</code>'s identifiers that didn't appear in <code>this</code>.  <a href="#ad2eed02898a13f56e0bc2a470c2f89af">More...</a><br /></td></tr>
<tr class="separator:ad2eed02898a13f56e0bc2a470c2f89af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb1fae3bb100c4a3391e523712d2dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4fb1fae3bb100c4a3391e523712d2dba">areIdsAlignedWithOther</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a4fb1fae3bb100c4a3391e523712d2dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order.  <a href="#a4fb1fae3bb100c4a3391e523712d2dba">More...</a><br /></td></tr>
<tr class="separator:a4fb1fae3bb100c4a3391e523712d2dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b3f9b979e0c1858e0e8bdf105498c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a536b3f9b979e0c1858e0e8bdf105498c">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;other) override</td></tr>
<tr class="memdesc:a536b3f9b979e0c1858e0e8bdf105498c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="An extension of FlatAffineConstraints in which dimensions and symbols can optionally be associated wi...">FlatAffineValueConstraints</a> with <code>other</code>.  <a href="#a536b3f9b979e0c1858e0e8bdf105498c">More...</a><br /></td></tr>
<tr class="separator:a536b3f9b979e0c1858e0e8bdf105498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3896e7ab007a7bd1e8d1fb1fb098bdea">getValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">More...</a><br /></td></tr>
<tr class="separator:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39afc73e0776e068eb7331bcb349c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5e39afc73e0776e068eb7331bcb349c7">hasValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a5e39afc73e0776e068eb7331bcb349c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a5e39afc73e0776e068eb7331bcb349c7">More...</a><br /></td></tr>
<tr class="separator:a5e39afc73e0776e068eb7331bcb349c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a6a4ea45324a6c969a5b5062ec932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a321a6a4ea45324a6c969a5b5062ec932">hasValues</a> () const</td></tr>
<tr class="memdesc:a321a6a4ea45324a6c969a5b5062ec932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a321a6a4ea45324a6c969a5b5062ec932">More...</a><br /></td></tr>
<tr class="separator:a321a6a4ea45324a6c969a5b5062ec932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc790e216f3bbf7416308c04045094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9ccc790e216f3bbf7416308c04045094">getValues</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="memdesc:a9ccc790e216f3bbf7416308c04045094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Values associated with identifiers in range [start, end).  <a href="#a9ccc790e216f3bbf7416308c04045094">More...</a><br /></td></tr>
<tr class="separator:a9ccc790e216f3bbf7416308c04045094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5177b199aa494103835274f72907a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af5177b199aa494103835274f72907a8b">getAllValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="separator:af5177b199aa494103835274f72907a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7998d8323c934c13a86769ca8fad877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad7998d8323c934c13a86769ca8fad877">getMaybeValues</a> () const</td></tr>
<tr class="separator:ad7998d8323c934c13a86769ca8fad877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61e7f65a2ddd3fb4dc389d1fcd4467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1e61e7f65a2ddd3fb4dc389d1fcd4467">getMaybeDimValues</a> () const</td></tr>
<tr class="separator:a1e61e7f65a2ddd3fb4dc389d1fcd4467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464901024f611db773f2def48443b8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a464901024f611db773f2def48443b8f8">getMaybeSymbolValues</a> () const</td></tr>
<tr class="separator:a464901024f611db773f2def48443b8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d108d7e10610afd56b9bc03598741f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a0d108d7e10610afd56b9bc03598741f9">getMaybeDimAndSymbolValues</a> () const</td></tr>
<tr class="separator:a0d108d7e10610afd56b9bc03598741f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5eccad1d331cf5cfb78bf1f08fda7224">setValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a5eccad1d331cf5cfb78bf1f08fda7224">More...</a><br /></td></tr>
<tr class="separator:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c65d604a6089bb16894e4a9ee33bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a320c65d604a6089bb16894e4a9ee33bf">setValues</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>)</td></tr>
<tr class="memdesc:a320c65d604a6089bb16894e4a9ee33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Values associated with the identifiers in the range [start, end).  <a href="#a320c65d604a6089bb16894e4a9ee33bf">More...</a><br /></td></tr>
<tr class="separator:a320c65d604a6089bb16894e4a9ee33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5333879b7e111caf2c3371c0d0745296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5333879b7e111caf2c3371c0d0745296">mergeSymbolIds</a> (<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a5333879b7e111caf2c3371c0d0745296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique.  <a href="#a5333879b7e111caf2c3371c0d0745296">More...</a><br /></td></tr>
<tr class="separator:a5333879b7e111caf2c3371c0d0745296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:ad696d4f93b157c44fec1e3965e850433 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad696d4f93b157c44fec1e3965e850433">FlatAffineConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals)</td></tr>
<tr class="memdesc:ad696d4f93b157c44fec1e3965e850433 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="classmlir_1_1FlatAffineConstraints.html#ad696d4f93b157c44fec1e3965e850433">More...</a><br /></td></tr>
<tr class="separator:ad696d4f93b157c44fec1e3965e850433 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128caef8d1284314f3220982733a7df inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac128caef8d1284314f3220982733a7df">FlatAffineConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:ac128caef8d1284314f3220982733a7df inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="classmlir_1_1FlatAffineConstraints.html#ac128caef8d1284314f3220982733a7df">More...</a><br /></td></tr>
<tr class="separator:ac128caef8d1284314f3220982733a7df inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541fd1bd1ee53f1c19add7b01b12e833 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a541fd1bd1ee53f1c19add7b01b12e833">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;poly)</td></tr>
<tr class="separator:a541fd1bd1ee53f1c19add7b01b12e833 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04009cfc4f3c97dbff1cf9594c0f7c9a inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">FlatAffineConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a04009cfc4f3c97dbff1cf9594c0f7c9a inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">More...</a><br /></td></tr>
<tr class="separator:a04009cfc4f3c97dbff1cf9594c0f7c9a inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074122b77beb705d010169667ae9efe inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8074122b77beb705d010169667ae9efe">FlatAffineConstraints</a> (const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;map)</td></tr>
<tr class="separator:a8074122b77beb705d010169667ae9efe inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45311e4a13b83b06d9c270a5446172f5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a45311e4a13b83b06d9c270a5446172f5">~FlatAffineConstraints</a> () override=default</td></tr>
<tr class="separator:a45311e4a13b83b06d9c270a5446172f5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0932fcc3e8ee32f1af944a1f33a9abc3 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0932fcc3e8ee32f1af944a1f33a9abc3">clone</a> () const</td></tr>
<tr class="separator:a0932fcc3e8ee32f1af944a1f33a9abc3 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520de7a96a9cdf5130756e58a42e6371 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a520de7a96a9cdf5130756e58a42e6371">addBound</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap)</td></tr>
<tr class="memdesc:a520de7a96a9cdf5130756e58a42e6371 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map.  <a href="classmlir_1_1FlatAffineConstraints.html#a520de7a96a9cdf5130756e58a42e6371">More...</a><br /></td></tr>
<tr class="separator:a520de7a96a9cdf5130756e58a42e6371 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ce04a3ec6c6baf9308f460ae14c751 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad9ce04a3ec6c6baf9308f460ae14c751">getAsIntegerSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ad9ce04a3ec6c6baf9308f460ae14c751 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint system as an integer set.  <a href="classmlir_1_1FlatAffineConstraints.html#ad9ce04a3ec6c6baf9308f460ae14c751">More...</a><br /></td></tr>
<tr class="separator:ad9ce04a3ec6c6baf9308f460ae14c751 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fe40151ae13ca4d10c425937ff70f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">getSliceBounds</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps)</td></tr>
<tr class="memdesc:a27fe40151ae13ca4d10c425937ff70f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lower and upper bounds of the first <code>num</code> dimensional identifiers (starting at <code>offset</code>) as an affine map of the remaining identifiers (dimensional and symbolic).  <a href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">More...</a><br /></td></tr>
<tr class="separator:a27fe40151ae13ca4d10c425937ff70f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f95bfc66876ee75db55381eafbb8f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="memdesc:a15f95bfc66876ee75db55381eafbb8f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">More...</a><br /></td></tr>
<tr class="separator:a15f95bfc66876ee75db55381eafbb8f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cdbe1cff606a9b364e734ca09dc52 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">getLowerAndUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:aad0cdbe1cff606a9b364e734ca09dc52 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols, and <code>pos</code> lies in [0, num).  <a href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">More...</a><br /></td></tr>
<tr class="separator:aad0cdbe1cff606a9b364e734ca09dc52 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:a3501f10308fee916c3f2d899f3994a06 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a3501f10308fee916c3f2d899f3994a06">IntegerPolyhedron</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals)</td></tr>
<tr class="memdesc:a3501f10308fee916c3f2d899f3994a06 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="classmlir_1_1IntegerPolyhedron.html#a3501f10308fee916c3f2d899f3994a06">More...</a><br /></td></tr>
<tr class="separator:a3501f10308fee916c3f2d899f3994a06 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1586990a764768bba6f547106d792485 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a1586990a764768bba6f547106d792485">IntegerPolyhedron</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:a1586990a764768bba6f547106d792485 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="classmlir_1_1IntegerPolyhedron.html#a1586990a764768bba6f547106d792485">More...</a><br /></td></tr>
<tr class="separator:a1586990a764768bba6f547106d792485 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bac06d2396336edc10f842b3123d151 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4bac06d2396336edc10f842b3123d151">~IntegerPolyhedron</a> ()=default</td></tr>
<tr class="separator:a4bac06d2396336edc10f842b3123d151 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ae519080bf303b244bde7d9d3b57ee13c">clone</a> () const</td></tr>
<tr class="separator:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0d8adfef18e063b082d99cef8d540 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac9d0d8adfef18e063b082d99cef8d540">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="separator:ac9d0d8adfef18e063b082d99cef8d540 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360ca3e1c7cf83b55e8902186df85fd inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a9360ca3e1c7cf83b55e8902186df85fd">append</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;other)</td></tr>
<tr class="memdesc:a9360ca3e1c7cf83b55e8902186df85fd inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends constraints from <code>other</code> into <code>this</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#a9360ca3e1c7cf83b55e8902186df85fd">More...</a><br /></td></tr>
<tr class="separator:a9360ca3e1c7cf83b55e8902186df85fd inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44beaa9fcdf33df89fd24236d984c3c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ab44beaa9fcdf33df89fd24236d984c3c">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:ab44beaa9fcdf33df89fd24236d984c3c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="classmlir_1_1IntegerPolyhedron.html#ab44beaa9fcdf33df89fd24236d984c3c">More...</a><br /></td></tr>
<tr class="separator:ab44beaa9fcdf33df89fd24236d984c3c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7845afe41fe57beaef7929df5ab064ff inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7845afe41fe57beaef7929df5ab064ff">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a7845afe41fe57beaef7929df5ab064ff inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd415defcb46be0860dc9d41bc72219b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afd415defcb46be0860dc9d41bc72219b">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:afd415defcb46be0860dc9d41bc72219b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified inequality row and column.  <a href="classmlir_1_1IntegerPolyhedron.html#afd415defcb46be0860dc9d41bc72219b">More...</a><br /></td></tr>
<tr class="separator:afd415defcb46be0860dc9d41bc72219b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20d60d4491633ecd8ef7bf9c018dc2a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad20d60d4491633ecd8ef7bf9c018dc2a">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:ad20d60d4491633ecd8ef7bf9c018dc2a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6729d0a4f3d7cf524c9d3182697af910 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a6729d0a4f3d7cf524c9d3182697af910">getNumConstraints</a> () const</td></tr>
<tr class="separator:a6729d0a4f3d7cf524c9d3182697af910 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325cdb95f80ea7f700b1098f96c4eeb2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a325cdb95f80ea7f700b1098f96c4eeb2">getNumIds</a> () const</td></tr>
<tr class="separator:a325cdb95f80ea7f700b1098f96c4eeb2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c82b907b69e86a74175af3b3656e0d9 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7c82b907b69e86a74175af3b3656e0d9">getNumDimIds</a> () const</td></tr>
<tr class="separator:a7c82b907b69e86a74175af3b3656e0d9 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e47e5e34d75aaae295fe38453927da inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a75e47e5e34d75aaae295fe38453927da">getNumSymbolIds</a> () const</td></tr>
<tr class="separator:a75e47e5e34d75aaae295fe38453927da inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b64806cefe23cbbd72f8260c69f83 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a585b64806cefe23cbbd72f8260c69f83">getNumDimAndSymbolIds</a> () const</td></tr>
<tr class="separator:a585b64806cefe23cbbd72f8260c69f83 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6b390d072fba4f1078ab5bfcf3a9b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4e6b390d072fba4f1078ab5bfcf3a9b7">getNumLocalIds</a> () const</td></tr>
<tr class="separator:a4e6b390d072fba4f1078ab5bfcf3a9b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489082b1b320a22b53e6c07dd6a1309 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7489082b1b320a22b53e6c07dd6a1309">getNumCols</a> () const</td></tr>
<tr class="memdesc:a7489082b1b320a22b53e6c07dd6a1309 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="classmlir_1_1IntegerPolyhedron.html#a7489082b1b320a22b53e6c07dd6a1309">More...</a><br /></td></tr>
<tr class="separator:a7489082b1b320a22b53e6c07dd6a1309 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7957b4460801b6a74789e4de7ab7e8b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7957b4460801b6a74789e4de7ab7e8b7">getNumEqualities</a> () const</td></tr>
<tr class="separator:a7957b4460801b6a74789e4de7ab7e8b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92467fbc77816a48e7f3b8566228cb5a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a92467fbc77816a48e7f3b8566228cb5a">getNumInequalities</a> () const</td></tr>
<tr class="separator:a92467fbc77816a48e7f3b8566228cb5a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aee9eb7cf477eb735f8ad47a2721fe inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ae4aee9eb7cf477eb735f8ad47a2721fe">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:ae4aee9eb7cf477eb735f8ad47a2721fe inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed465b2e8cd89724f098f1ceca052fef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aed465b2e8cd89724f098f1ceca052fef">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:aed465b2e8cd89724f098f1ceca052fef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef5b6cf6f461b4e1c15b365c284ace1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#abef5b6cf6f461b4e1c15b365c284ace1">getEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:abef5b6cf6f461b4e1c15b365c284ace1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86817d70ff79e0f33b7c8291d17f043f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a86817d70ff79e0f33b7c8291d17f043f">getInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:a86817d70ff79e0f33b7c8291d17f043f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176f55575a99f416b3d3493c8450b032 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a176f55575a99f416b3d3493c8450b032">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:a176f55575a99f416b3d3493c8450b032 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>num</code> identifiers of the specified kind at position <code>pos</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#a176f55575a99f416b3d3493c8450b032">More...</a><br /></td></tr>
<tr class="separator:a176f55575a99f416b3d3493c8450b032 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d499b36bfd9e8fffb2e00493501ce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aaa5d499b36bfd9e8fffb2e00493501ce">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:aaa5d499b36bfd9e8fffb2e00493501ce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c796331c696fff5d5873394e43415d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a00c796331c696fff5d5873394e43415d">insertLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a00c796331c696fff5d5873394e43415d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398c3ef2afff3bf90c2d36686de1f5a4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a398c3ef2afff3bf90c2d36686de1f5a4">appendDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:a398c3ef2afff3bf90c2d36686de1f5a4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <code>num</code> identifiers of the specified kind after the last identifier.  <a href="classmlir_1_1IntegerPolyhedron.html#a398c3ef2afff3bf90c2d36686de1f5a4">More...</a><br /></td></tr>
<tr class="separator:a398c3ef2afff3bf90c2d36686de1f5a4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7368fdf3751bcf749fef64c2aaa8b6d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad7368fdf3751bcf749fef64c2aaa8b6d">appendSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:ad7368fdf3751bcf749fef64c2aaa8b6d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40399291a13818f59bccdfa6836f129 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac40399291a13818f59bccdfa6836f129">appendLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:ac40399291a13818f59bccdfa6836f129 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4807617a443edaece02bad5624a90cc inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac4807617a443edaece02bad5624a90cc">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="memdesc:ac4807617a443edaece02bad5624a90cc inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an inequality (&gt;= 0) from the coefficients specified in <code>inEq</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#ac4807617a443edaece02bad5624a90cc">More...</a><br /></td></tr>
<tr class="separator:ac4807617a443edaece02bad5624a90cc inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9dc5cc6ab049a0039895e757a89ac inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac1d9dc5cc6ab049a0039895e757a89ac">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="memdesc:ac1d9dc5cc6ab049a0039895e757a89ac inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an equality from the coefficients specified in <code>eq</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#ac1d9dc5cc6ab049a0039895e757a89ac">More...</a><br /></td></tr>
<tr class="separator:ac1d9dc5cc6ab049a0039895e757a89ac inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601403d3007ad399ccb10c2900a2cda0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a601403d3007ad399ccb10c2900a2cda0">removeId</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a601403d3007ad399ccb10c2900a2cda0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers of the specified kind with the specified pos (or within the specified range) from the system.  <a href="classmlir_1_1IntegerPolyhedron.html#a601403d3007ad399ccb10c2900a2cda0">More...</a><br /></td></tr>
<tr class="separator:a601403d3007ad399ccb10c2900a2cda0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3531b899e53eb59cf8c493869ddd33 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7c3531b899e53eb59cf8c493869ddd33">removeIdRange</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit)</td></tr>
<tr class="separator:a7c3531b899e53eb59cf8c493869ddd33 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0057caf049402c9b336bda7fabd604ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0057caf049402c9b336bda7fabd604ee">removeId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a0057caf049402c9b336bda7fabd604ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified identifier from the system.  <a href="classmlir_1_1IntegerPolyhedron.html#a0057caf049402c9b336bda7fabd604ee">More...</a><br /></td></tr>
<tr class="separator:a0057caf049402c9b336bda7fabd604ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaae4a8339cc069d3674de26acb60e7a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#abaae4a8339cc069d3674de26acb60e7a">removeEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:abaae4a8339cc069d3674de26acb60e7a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a47e2c94aa9c20ced486fac1ec7f7ef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a2a47e2c94aa9c20ced486fac1ec7f7ef">removeInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a2a47e2c94aa9c20ced486fac1ec7f7ef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267749ba42f9a0290f5f337eb02d8799 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a267749ba42f9a0290f5f337eb02d8799">removeEqualityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="memdesc:a267749ba42f9a0290f5f337eb02d8799 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the (in)equalities at positions [start, end).  <a href="classmlir_1_1IntegerPolyhedron.html#a267749ba42f9a0290f5f337eb02d8799">More...</a><br /></td></tr>
<tr class="separator:a267749ba42f9a0290f5f337eb02d8799 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210bbd3864400b3eb4921e912bec915e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a210bbd3864400b3eb4921e912bec915e">removeInequalityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="separator:a210bbd3864400b3eb4921e912bec915e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d628b81e01098fbd05a3c0be47b34 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a630d628b81e01098fbd05a3c0be47b34">clearConstraints</a> ()</td></tr>
<tr class="memdesc:a630d628b81e01098fbd05a3c0be47b34 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all equalities and inequalities.  <a href="classmlir_1_1IntegerPolyhedron.html#a630d628b81e01098fbd05a3c0be47b34">More...</a><br /></td></tr>
<tr class="separator:a630d628b81e01098fbd05a3c0be47b34 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba6009d283937de4eda879cda0aab44 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#abba6009d283937de4eda879cda0aab44">setAndEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:abba6009d283937de4eda879cda0aab44 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>values.size()</code> identifiers starting at <code>po</code>s to the specified values and removes them.  <a href="classmlir_1_1IntegerPolyhedron.html#abba6009d283937de4eda879cda0aab44">More...</a><br /></td></tr>
<tr class="separator:abba6009d283937de4eda879cda0aab44 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132c1a20471286db9060978b217def86 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a132c1a20471286db9060978b217def86">getLowerAndUpperBoundIndices</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *lbIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *ubIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *eqIndices=nullptr, <a class="el" href="classunsigned.html">unsigned</a> offset=0, <a class="el" href="classunsigned.html">unsigned</a> num=0) const</td></tr>
<tr class="memdesc:a132c1a20471286db9060978b217def86 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather positions of all lower and upper bounds of the identifier at <code>pos</code>, and optionally any equalities on it.  <a href="classmlir_1_1IntegerPolyhedron.html#a132c1a20471286db9060978b217def86">More...</a><br /></td></tr>
<tr class="separator:a132c1a20471286db9060978b217def86 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cc0c1bb565c70e6a4c36a87b6e1ae2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#af0cc0c1bb565c70e6a4c36a87b6e1ae2">isEmpty</a> () const</td></tr>
<tr class="memdesc:af0cc0c1bb565c70e6a4c36a87b6e1ae2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for emptiness by performing variable elimination on all identifiers, running the GCD test on each equality constraint, and checking for invalid constraints.  <a href="classmlir_1_1IntegerPolyhedron.html#af0cc0c1bb565c70e6a4c36a87b6e1ae2">More...</a><br /></td></tr>
<tr class="separator:af0cc0c1bb565c70e6a4c36a87b6e1ae2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ab83db48c0a636534755c13e1300bb inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad1ab83db48c0a636534755c13e1300bb">isEmptyByGCDTest</a> () const</td></tr>
<tr class="memdesc:ad1ab83db48c0a636534755c13e1300bb inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the GCD test on all equality constraints.  <a href="classmlir_1_1IntegerPolyhedron.html#ad1ab83db48c0a636534755c13e1300bb">More...</a><br /></td></tr>
<tr class="separator:ad1ab83db48c0a636534755c13e1300bb inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740aa6d1e10248ec3cf12c18c37ae90 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4740aa6d1e10248ec3cf12c18c37ae90">isIntegerEmpty</a> () const</td></tr>
<tr class="memdesc:a4740aa6d1e10248ec3cf12c18c37ae90 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set of constraints is found to have no solution, false if a solution exists.  <a href="classmlir_1_1IntegerPolyhedron.html#a4740aa6d1e10248ec3cf12c18c37ae90">More...</a><br /></td></tr>
<tr class="separator:a4740aa6d1e10248ec3cf12c18c37ae90 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf0efe422bf5031f97b676cbf366d79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a8cf0efe422bf5031f97b676cbf366d79">getBoundedDirections</a> () const</td></tr>
<tr class="memdesc:a8cf0efe422bf5031f97b676cbf366d79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix where each row is a vector along which the polytope is bounded.  <a href="classmlir_1_1IntegerPolyhedron.html#a8cf0efe422bf5031f97b676cbf366d79">More...</a><br /></td></tr>
<tr class="separator:a8cf0efe422bf5031f97b676cbf366d79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f2759f8c64b60dd97d6111cb8c4bb0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa6f2759f8c64b60dd97d6111cb8c4bb0">findIntegerSample</a> () const</td></tr>
<tr class="memdesc:aa6f2759f8c64b60dd97d6111cb8c4bb0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an integer sample point satisfying the constraints using a branch and bound algorithm with generalized basis reduction, with some additional processing using <a class="el" href="classmlir_1_1Simplex.html">Simplex</a> for unbounded sets.  <a href="classmlir_1_1IntegerPolyhedron.html#aa6f2759f8c64b60dd97d6111cb8c4bb0">More...</a><br /></td></tr>
<tr class="separator:aa6f2759f8c64b60dd97d6111cb8c4bb0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b100f28b410f31771a408a450502d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa26b100f28b410f31771a408a450502d">containsPoint</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="memdesc:aa26b100f28b410f31771a408a450502d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point satisfies the constraints, or false otherwise.  <a href="classmlir_1_1IntegerPolyhedron.html#aa26b100f28b410f31771a408a450502d">More...</a><br /></td></tr>
<tr class="separator:aa26b100f28b410f31771a408a450502d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8893becd671b144216b41f28c87decc1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a8893becd671b144216b41f28c87decc1">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators, std::vector&lt; <a class="el" href="structmlir_1_1presburger__utils_1_1MaybeLocalRepr.html">presburger_utils::MaybeLocalRepr</a> &gt; &amp;repr) const</td></tr>
<tr class="memdesc:a8893becd671b144216b41f28c87decc1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pairs of inequalities identified by their position indices, using which an explicit representation for each local variable can be computed.  <a href="classmlir_1_1IntegerPolyhedron.html#a8893becd671b144216b41f28c87decc1">More...</a><br /></td></tr>
<tr class="separator:a8893becd671b144216b41f28c87decc1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab264a24756d7833bc0bd9241defba1a6 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ab264a24756d7833bc0bd9241defba1a6">getLocalReprs</a> (std::vector&lt; <a class="el" href="structmlir_1_1presburger__utils_1_1MaybeLocalRepr.html">presburger_utils::MaybeLocalRepr</a> &gt; &amp;repr) const</td></tr>
<tr class="separator:ab264a24756d7833bc0bd9241defba1a6 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a0331f1464b9c50e8169d23b6b9d49 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a34a0331f1464b9c50e8169d23b6b9d49">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators) const</td></tr>
<tr class="separator:a34a0331f1464b9c50e8169d23b6b9d49 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f246c28f461309273919ec8df05a74 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a84f246c28f461309273919ec8df05a74">addBound</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a84f246c28f461309273919ec8df05a74 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified identifier.  <a href="classmlir_1_1IntegerPolyhedron.html#a84f246c28f461309273919ec8df05a74">More...</a><br /></td></tr>
<tr class="separator:a84f246c28f461309273919ec8df05a74 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5cddd2c432414646ddfdbb157579c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a08a5cddd2c432414646ddfdbb157579c">addBound</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a08a5cddd2c432414646ddfdbb157579c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified expression.  <a href="classmlir_1_1IntegerPolyhedron.html#a08a5cddd2c432414646ddfdbb157579c">More...</a><br /></td></tr>
<tr class="separator:a08a5cddd2c432414646ddfdbb157579c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f3da8ed04e5d42c1656a76e5b1d52d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad4f3da8ed04e5d42c1656a76e5b1d52d">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="memdesc:ad4f3da8ed04e5d42c1656a76e5b1d52d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in <code>dividend</code> and with respect to a positive constant <code>divisor</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#ad4f3da8ed04e5d42c1656a76e5b1d52d">More...</a><br /></td></tr>
<tr class="separator:ad4f3da8ed04e5d42c1656a76e5b1d52d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64b71451f1680ce83386b6fcedabce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aab64b71451f1680ce83386b6fcedabce">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:aab64b71451f1680ce83386b6fcedabce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out (aka eliminates) <code>num</code> identifiers starting at position <code>pos</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#aab64b71451f1680ce83386b6fcedabce">More...</a><br /></td></tr>
<tr class="separator:aab64b71451f1680ce83386b6fcedabce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b39cd6970dcae4ed6a4197a3d615e3 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a63b39cd6970dcae4ed6a4197a3d615e3">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a63b39cd6970dcae4ed6a4197a3d615e3 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fb5dcc8ec5b711d0e1a1ddb38c4b09 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ab7fb5dcc8ec5b711d0e1a1ddb38c4b09">setDimSymbolSeparation</a> (<a class="el" href="classunsigned.html">unsigned</a> newSymbolCount)</td></tr>
<tr class="memdesc:ab7fb5dcc8ec5b711d0e1a1ddb38c4b09 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the partition between dimensions and symbols.  <a href="classmlir_1_1IntegerPolyhedron.html#ab7fb5dcc8ec5b711d0e1a1ddb38c4b09">More...</a><br /></td></tr>
<tr class="separator:ab7fb5dcc8ec5b711d0e1a1ddb38c4b09 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b71f340fe61f5698131727a202225f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#af0b71f340fe61f5698131727a202225f">constantFoldId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:af0b71f340fe61f5698131727a202225f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system.  <a href="classmlir_1_1IntegerPolyhedron.html#af0b71f340fe61f5698131727a202225f">More...</a><br /></td></tr>
<tr class="separator:af0b71f340fe61f5698131727a202225f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd29bbedd54460d803341161fbb8494 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7fd29bbedd54460d803341161fbb8494">constantFoldIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:a7fd29bbedd54460d803341161fbb8494 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calls <code>constantFoldId</code> for the specified range of identifiers, <code>num</code> identifiers starting at position <code>pos</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#a7fd29bbedd54460d803341161fbb8494">More...</a><br /></td></tr>
<tr class="separator:a7fd29bbedd54460d803341161fbb8494 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec676b82642e6d09076908aa59eb47d0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aec676b82642e6d09076908aa59eb47d0">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;other)</td></tr>
<tr class="memdesc:aec676b82642e6d09076908aa59eb47d0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="classmlir_1_1IntegerPolyhedron.html#aec676b82642e6d09076908aa59eb47d0">More...</a><br /></td></tr>
<tr class="separator:aec676b82642e6d09076908aa59eb47d0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227a3e006b98ccfbdb24198e87e6aa3d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a227a3e006b98ccfbdb24198e87e6aa3d">getConstantBoundOnDimSize</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *boundFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minLbPos=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minUbPos=nullptr) const</td></tr>
<tr class="memdesc:a227a3e006b98ccfbdb24198e87e6aa3d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier.  <a href="classmlir_1_1IntegerPolyhedron.html#a227a3e006b98ccfbdb24198e87e6aa3d">More...</a><br /></td></tr>
<tr class="separator:a227a3e006b98ccfbdb24198e87e6aa3d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad74497a4b05ac38f48bbd13a2d720b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a3ad74497a4b05ac38f48bbd13a2d720b">getConstantBound</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a3ad74497a4b05ac38f48bbd13a2d720b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant bound for the pos^th identifier if there is one; None otherwise.  <a href="classmlir_1_1IntegerPolyhedron.html#a3ad74497a4b05ac38f48bbd13a2d720b">More...</a><br /></td></tr>
<tr class="separator:a3ad74497a4b05ac38f48bbd13a2d720b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7798f6ced7210a387a1d2baf62c0009 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ae7798f6ced7210a387a1d2baf62c0009">removeIndependentConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:ae7798f6ced7210a387a1d2baf62c0009 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes constraints that are independent of (i.e., do not have a coefficient) identifiers in the range [pos, pos + num).  <a href="classmlir_1_1IntegerPolyhedron.html#ae7798f6ced7210a387a1d2baf62c0009">More...</a><br /></td></tr>
<tr class="separator:ae7798f6ced7210a387a1d2baf62c0009 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80977f5f0d392df93526e590bcb271ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a80977f5f0d392df93526e590bcb271ee">isHyperRectangular</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num) const</td></tr>
<tr class="memdesc:a80977f5f0d392df93526e590bcb271ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers.  <a href="classmlir_1_1IntegerPolyhedron.html#a80977f5f0d392df93526e590bcb271ee">More...</a><br /></td></tr>
<tr class="separator:a80977f5f0d392df93526e590bcb271ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893a1efc4a6c8acf8e91a9890a099606 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a893a1efc4a6c8acf8e91a9890a099606">removeTrivialRedundancy</a> ()</td></tr>
<tr class="memdesc:a893a1efc4a6c8acf8e91a9890a099606 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part.  <a href="classmlir_1_1IntegerPolyhedron.html#a893a1efc4a6c8acf8e91a9890a099606">More...</a><br /></td></tr>
<tr class="separator:a893a1efc4a6c8acf8e91a9890a099606 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0b8c11360192c2fd468b8ac35baca0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a3c0b8c11360192c2fd468b8ac35baca0">removeRedundantInequalities</a> ()</td></tr>
<tr class="memdesc:a3c0b8c11360192c2fd468b8ac35baca0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more expensive check than <code>removeTrivialRedundancy</code> to detect redundant inequalities.  <a href="classmlir_1_1IntegerPolyhedron.html#a3c0b8c11360192c2fd468b8ac35baca0">More...</a><br /></td></tr>
<tr class="separator:a3c0b8c11360192c2fd468b8ac35baca0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d3bf4a5e4a70872faa1effbbce9f2e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa1d3bf4a5e4a70872faa1effbbce9f2e">removeRedundantConstraints</a> ()</td></tr>
<tr class="memdesc:aa1d3bf4a5e4a70872faa1effbbce9f2e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant constraints using <a class="el" href="classmlir_1_1Simplex.html">Simplex</a>.  <a href="classmlir_1_1IntegerPolyhedron.html#aa1d3bf4a5e4a70872faa1effbbce9f2e">More...</a><br /></td></tr>
<tr class="separator:aa1d3bf4a5e4a70872faa1effbbce9f2e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20659595bca4177cb4071b22447291c4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a20659595bca4177cb4071b22447291c4">convertDimToLocal</a> (<a class="el" href="classunsigned.html">unsigned</a> dimStart, <a class="el" href="classunsigned.html">unsigned</a> dimLimit)</td></tr>
<tr class="memdesc:a20659595bca4177cb4071b22447291c4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts identifiers in the column range [idStart, idLimit) to local variables.  <a href="classmlir_1_1IntegerPolyhedron.html#a20659595bca4177cb4071b22447291c4">More...</a><br /></td></tr>
<tr class="separator:a20659595bca4177cb4071b22447291c4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02143308702328c875d23b35740b4b55 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a02143308702328c875d23b35740b4b55">mergeLocalIds</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;other)</td></tr>
<tr class="memdesc:a02143308702328c875d23b35740b4b55 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional local ids to the sets such that they both have the union of the local ids in each set, without changing the set of points that lie in <code>this</code> and <code>other</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#a02143308702328c875d23b35740b4b55">More...</a><br /></td></tr>
<tr class="separator:a02143308702328c875d23b35740b4b55 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb075bff7cc53c3fd8108b962685e879 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afb075bff7cc53c3fd8108b962685e879">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:afb075bff7cc53c3fd8108b962685e879 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2b93ee707f8d49c423f96b10292c79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4e2b93ee707f8d49c423f96b10292c79">dump</a> () const</td></tr>
<tr class="separator:a4e2b93ee707f8d49c423f96b10292c79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acfee23f39d31078e69df752b973f53b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acfee23f39d31078e69df752b973f53b6">getHyperrectangular</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs)</td></tr>
<tr class="separator:acfee23f39d31078e69df752b973f53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0940692949476995f8facfddffa4f31"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae0940692949476995f8facfddffa4f31">classof</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> *cst)</td></tr>
<tr class="separator:ae0940692949476995f8facfddffa4f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:abe0c6f1821da05edc091e82d187e0e10 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#abe0c6f1821da05edc091e82d187e0e10">getUniverse</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0)</td></tr>
<tr class="memdesc:abe0c6f1821da05edc091e82d187e0e10 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1FlatAffineConstraints.html#abe0c6f1821da05edc091e82d187e0e10">More...</a><br /></td></tr>
<tr class="separator:abe0c6f1821da05edc091e82d187e0e10 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853122ffbc780c15a66eac4f52c83be8 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a853122ffbc780c15a66eac4f52c83be8">classof</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> *cst)</td></tr>
<tr class="separator:a853122ffbc780c15a66eac4f52c83be8 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:ad8d4bd03e5f0afbc0d7ff81519ca3012 inherit pub_static_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad8d4bd03e5f0afbc0d7ff81519ca3012">getUniverse</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0)</td></tr>
<tr class="memdesc:ad8d4bd03e5f0afbc0d7ff81519ca3012 inherit pub_static_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1IntegerPolyhedron.html#ad8d4bd03e5f0afbc0d7ff81519ca3012">More...</a><br /></td></tr>
<tr class="separator:ad8d4bd03e5f0afbc0d7ff81519ca3012 inherit pub_static_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177a8c721e0cb6c12d64b897657e2a0f inherit pub_static_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a177a8c721e0cb6c12d64b897657e2a0f">classof</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> *cst)</td></tr>
<tr class="separator:a177a8c721e0cb6c12d64b897657e2a0f inherit pub_static_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3202cddcf31d0798de72cac6742248b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3202cddcf31d0798de72cac6742248b0">hasConsistentState</a> () const override</td></tr>
<tr class="memdesc:a3202cddcf31d0798de72cac6742248b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise.  <a href="#a3202cddcf31d0798de72cac6742248b0">More...</a><br /></td></tr>
<tr class="separator:a3202cddcf31d0798de72cac6742248b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b415d11d42c0a1e02bc2c35833d3a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2b415d11d42c0a1e02bc2c35833d3a2d">removeIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit) override</td></tr>
<tr class="memdesc:a2b415d11d42c0a1e02bc2c35833d3a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="#a2b415d11d42c0a1e02bc2c35833d3a2d">More...</a><br /></td></tr>
<tr class="separator:a2b415d11d42c0a1e02bc2c35833d3a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3ca6765edfa5677b1b23130e0187c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a30b3ca6765edfa5677b1b23130e0187c">fourierMotzkinEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, bool darkShadow=false, bool *isResultIntegerExact=nullptr) override</td></tr>
<tr class="memdesc:a30b3ca6765edfa5677b1b23130e0187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier.  <a href="#a30b3ca6765edfa5677b1b23130e0187c">More...</a><br /></td></tr>
<tr class="separator:a30b3ca6765edfa5677b1b23130e0187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:a38c97661a1c86284a9102a06018c7292 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a38c97661a1c86284a9102a06018c7292">flattenAlignedMapAndMergeLocals</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="memdesc:a38c97661a1c86284a9102a06018c7292 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map that is aligned with this constraint system:  <a href="classmlir_1_1FlatAffineConstraints.html#a38c97661a1c86284a9102a06018c7292">More...</a><br /></td></tr>
<tr class="separator:a38c97661a1c86284a9102a06018c7292 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12923f47851694f80045567e8d2c27c7 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a12923f47851694f80045567e8d2c27c7">printSpace</a> (raw_ostream &amp;os) const override</td></tr>
<tr class="memdesc:a12923f47851694f80045567e8d2c27c7 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of constraints, dimensions, symbols and locals in the <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#a12923f47851694f80045567e8d2c27c7">More...</a><br /></td></tr>
<tr class="separator:a12923f47851694f80045567e8d2c27c7 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:a743a503fdd8c3fc781e76c8a9cac7621 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a743a503fdd8c3fc781e76c8a9cac7621">hasInvalidConstraint</a> () const</td></tr>
<tr class="memdesc:a743a503fdd8c3fc781e76c8a9cac7621 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all rows of equality/inequality constraints for trivial contradictions (for example: 1 == 0, 0 &gt;= 1), which may have surfaced after elimination.  <a href="classmlir_1_1IntegerPolyhedron.html#a743a503fdd8c3fc781e76c8a9cac7621">More...</a><br /></td></tr>
<tr class="separator:a743a503fdd8c3fc781e76c8a9cac7621 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a07ffdfb15efd4d505c1fc49542091 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memTemplParams" colspan="2">template&lt;bool isLower&gt; </td></tr>
<tr class="memitem:aa3a07ffdfb15efd4d505c1fc49542091 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa3a07ffdfb15efd4d505c1fc49542091">computeConstantLowerOrUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:aa3a07ffdfb15efd4d505c1fc49542091 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant lower bound bound if isLower is true, and the upper bound if isLower is false.  <a href="classmlir_1_1IntegerPolyhedron.html#aa3a07ffdfb15efd4d505c1fc49542091">More...</a><br /></td></tr>
<tr class="separator:aa3a07ffdfb15efd4d505c1fc49542091 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9665f694a2c591945db62d51e7a4c776 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a9665f694a2c591945db62d51e7a4c776">gaussianEliminateId</a> (<a class="el" href="classunsigned.html">unsigned</a> position)</td></tr>
<tr class="memdesc:a9665f694a2c591945db62d51e7a4c776 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates a single identifier at <code>position</code> from equality and inequality constraints.  <a href="classmlir_1_1IntegerPolyhedron.html#a9665f694a2c591945db62d51e7a4c776">More...</a><br /></td></tr>
<tr class="separator:a9665f694a2c591945db62d51e7a4c776 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfe7aab9e47c52ca60cbeb9350eaaa0 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a9cfe7aab9e47c52ca60cbeb9350eaaa0">removeRedundantLocalVars</a> ()</td></tr>
<tr class="memdesc:a9cfe7aab9e47c52ca60cbeb9350eaaa0 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes local variables using equalities.  <a href="classmlir_1_1IntegerPolyhedron.html#a9cfe7aab9e47c52ca60cbeb9350eaaa0">More...</a><br /></td></tr>
<tr class="separator:a9cfe7aab9e47c52ca60cbeb9350eaaa0 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f1f49d2bdb52f698a15ab769de7f66 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a66f1f49d2bdb52f698a15ab769de7f66">gaussianEliminateIds</a> (<a class="el" href="classunsigned.html">unsigned</a> posStart, <a class="el" href="classunsigned.html">unsigned</a> posLimit)</td></tr>
<tr class="memdesc:a66f1f49d2bdb52f698a15ab769de7f66 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates identifiers from equality and inequality constraints in column range [posStart, posLimit).  <a href="classmlir_1_1IntegerPolyhedron.html#a66f1f49d2bdb52f698a15ab769de7f66">More...</a><br /></td></tr>
<tr class="separator:a66f1f49d2bdb52f698a15ab769de7f66 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d480a4a046c469796832262d6c1c56 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a79d480a4a046c469796832262d6c1c56">gcdTightenInequalities</a> ()</td></tr>
<tr class="memdesc:a79d480a4a046c469796832262d6c1c56 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tightens inequalities given that we are dealing with integer spaces.  <a href="classmlir_1_1IntegerPolyhedron.html#a79d480a4a046c469796832262d6c1c56">More...</a><br /></td></tr>
<tr class="separator:a79d480a4a046c469796832262d6c1c56 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a37c541e00b35da1479050d8d11be23 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0a37c541e00b35da1479050d8d11be23">normalizeConstraintsByGCD</a> ()</td></tr>
<tr class="memdesc:a0a37c541e00b35da1479050d8d11be23 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized each constraints by the GCD of its coefficients.  <a href="classmlir_1_1IntegerPolyhedron.html#a0a37c541e00b35da1479050d8d11be23">More...</a><br /></td></tr>
<tr class="separator:a0a37c541e00b35da1479050d8d11be23 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa717a3c66a79fd1e39c85bd29fc523a inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afa717a3c66a79fd1e39c85bd29fc523a">findConstraintWithNonZeroAt</a> (<a class="el" href="classunsigned.html">unsigned</a> colIdx, bool isEq, <a class="el" href="classunsigned.html">unsigned</a> *rowIdx) const</td></tr>
<tr class="memdesc:afa717a3c66a79fd1e39c85bd29fc523a inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a constraint with a non-zero coefficient at <code>colIdx</code> in equality (isEq=true) or inequality (isEq=false) constraints.  <a href="classmlir_1_1IntegerPolyhedron.html#afa717a3c66a79fd1e39c85bd29fc523a">More...</a><br /></td></tr>
<tr class="separator:afa717a3c66a79fd1e39c85bd29fc523a inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b98d327b156e6d0ea7f155bcb2610e6 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a2b98d327b156e6d0ea7f155bcb2610e6">isColZero</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a2b98d327b156e6d0ea7f155bcb2610e6 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th column is all zero for both inequalities and equalities.  <a href="classmlir_1_1IntegerPolyhedron.html#a2b98d327b156e6d0ea7f155bcb2610e6">More...</a><br /></td></tr>
<tr class="separator:a2b98d327b156e6d0ea7f155bcb2610e6 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8329cea65520ec9250d69774587b9278 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a8329cea65520ec9250d69774587b9278">getIdKindOffset</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind) const</td></tr>
<tr class="memdesc:a8329cea65520ec9250d69774587b9278 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at which the specified kind of id starts.  <a href="classmlir_1_1IntegerPolyhedron.html#a8329cea65520ec9250d69774587b9278">More...</a><br /></td></tr>
<tr class="separator:a8329cea65520ec9250d69774587b9278 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae8df118e423070fca2e7474cb46dc3 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afae8df118e423070fca2e7474cb46dc3">getNumIdKind</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind) const</td></tr>
<tr class="memdesc:afae8df118e423070fca2e7474cb46dc3 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ids of the specified kind.  <a href="classmlir_1_1IntegerPolyhedron.html#afae8df118e423070fca2e7474cb46dc3">More...</a><br /></td></tr>
<tr class="separator:afae8df118e423070fca2e7474cb46dc3 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2662045a8d845c7cf9aa9516af6ea914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a></td></tr>
<tr class="memdesc:a2662045a8d845c7cf9aa9516af6ea914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values corresponding to the (column) identifiers of this constraint system appearing in the order the identifiers correspond to columns.  <a href="#a2662045a8d845c7cf9aa9516af6ea914">More...</a><br /></td></tr>
<tr class="separator:a2662045a8d845c7cf9aa9516af6ea914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:ac147d7a4f5baaf408a7c70f026a4355b inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac147d7a4f5baaf408a7c70f026a4355b">numIds</a></td></tr>
<tr class="memdesc:ac147d7a4f5baaf408a7c70f026a4355b inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of identifiers.  <a href="classmlir_1_1IntegerPolyhedron.html#ac147d7a4f5baaf408a7c70f026a4355b">More...</a><br /></td></tr>
<tr class="separator:ac147d7a4f5baaf408a7c70f026a4355b inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f347cefc5dd82d88ab77e4b885638 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a></td></tr>
<tr class="memdesc:a825f347cefc5dd82d88ab77e4b885638 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of identifiers corresponding to real dimensions.  <a href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">More...</a><br /></td></tr>
<tr class="separator:a825f347cefc5dd82d88ab77e4b885638 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782e4532eead025a6922187706bdda18 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a></td></tr>
<tr class="memdesc:a782e4532eead025a6922187706bdda18 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of identifiers corresponding to symbols (unknown but constant for analysis).  <a href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">More...</a><br /></td></tr>
<tr class="separator:a782e4532eead025a6922187706bdda18 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74db4f4a7eda57e3ac5c079403a60f inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7a74db4f4a7eda57e3ac5c079403a60f">equalities</a></td></tr>
<tr class="memdesc:a7a74db4f4a7eda57e3ac5c079403a60f inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine equalities (in == 0 form).  <a href="classmlir_1_1IntegerPolyhedron.html#a7a74db4f4a7eda57e3ac5c079403a60f">More...</a><br /></td></tr>
<tr class="separator:a7a74db4f4a7eda57e3ac5c079403a60f inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6b46b43e6b951daab2ac2cbfbf3da8 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aec6b46b43e6b951daab2ac2cbfbf3da8">inequalities</a></td></tr>
<tr class="memdesc:aec6b46b43e6b951daab2ac2cbfbf3da8 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine inequalities (in &gt;= 0 form).  <a href="classmlir_1_1IntegerPolyhedron.html#aec6b46b43e6b951daab2ac2cbfbf3da8">More...</a><br /></td></tr>
<tr class="separator:aec6b46b43e6b951daab2ac2cbfbf3da8 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:aa08391a9530a1fffa288d92c0bd50a30 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30">Kind</a> { <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30a5d3c39d196a997e225b4f3ee3e1da745">Kind::FlatAffineConstraints</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30a38bdec3fb5cb6b2e66b5acddb32f9cb4">Kind::FlatAffineValueConstraints</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30aaaa02ac14b63aada677a5426f1782df9">Kind::IntegerPolyhedron</a>
 }<tr class="memdesc:aa08391a9530a1fffa288d92c0bd50a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">All derived classes of <a class="el" href="classmlir_1_1IntegerPolyhedron.html" title="An integer polyhedron is the set of solutions to a list of affine constraints over n integer-valued v...">IntegerPolyhedron</a>.  <a href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa08391a9530a1fffa288d92c0bd50a30 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e74388f8cbbd8cd5b47e9035592a5d8 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> { <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8adb86e099c97d96d33d373cba8f860641">Dimension</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8a3769694bd380edd81de25eb77f9b6597">Symbol</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8a5dfcedefe2c19bfd34ecc0e4f20cf0f3">Local</a>
 }<tr class="memdesc:a0e74388f8cbbd8cd5b47e9035592a5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of identifier (column).  <a href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0e74388f8cbbd8cd5b47e9035592a5d8 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45db7553a19f068448846a3fe254819 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a> { <a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819a8d5149cf045e7c4fdf8828394aef18eb">EQ</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819a468fea7f1369d3514d1f56919becac10">LB</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819a340ad0cd1fbb4e2d009338104c77ba59">UB</a>
 }<tr class="memdesc:ad45db7553a19f068448846a3fe254819"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of bound: equal, lower bound or upper bound.  <a href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad45db7553a19f068448846a3fe254819 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:ada88dd03231affae1386dbd887301db5 inherit pro_static_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ada88dd03231affae1386dbd887301db5">kExplosionFactor</a> = 32</td></tr>
<tr class="memdesc:ada88dd03231affae1386dbd887301db5 inherit pro_static_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parameter that controls detection of an unrealistic number of constraints.  <a href="classmlir_1_1IntegerPolyhedron.html#ada88dd03231affae1386dbd887301db5">More...</a><br /></td></tr>
<tr class="separator:ada88dd03231affae1386dbd887301db5 inherit pro_static_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An extension of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> in which dimensions and symbols can optionally be associated with an SSA value. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00180">180</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaec51cfb6129c7a10dbf24740897cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec51cfb6129c7a10dbf24740897cf1b">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system reserving memory for the specified number of constraints and identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00184">184</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00064">mlir::FlatAffineConstraints::FlatAffineConstraints()</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00246">reset()</a>.</p>

</div>
</div>
<a id="a8ba51af6e35a94b11d73b5215a35ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba51af6e35a94b11d73b5215a35ff7a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00202">202</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="ac652e97cab7cf64e3bef1b3418692a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac652e97cab7cf64e3bef1b3418692a2a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00211">211</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00064">mlir::FlatAffineConstraints::FlatAffineConstraints()</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>.</p>

</div>
</div>
<a id="af048f5fb19968688b331c7bb0f8d9a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af048f5fb19968688b331c7bb0f8d9a4d">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>avm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these. </p>
<p>The constructed system will only include equalities. </p>

</div>
</div>
<a id="a0aa32c847534d57cff25fdfa654778e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa32c847534d57cff25fdfa654778e0">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa812729dd90454f1c10517520dde9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa812729dd90454f1c10517520dde9a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00189">189</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1presburger__utils.html#a481b3a20e5591036f0e10ed3c284c964a6adf97f83acf6453d4a6a4b1070f3754">mlir::presburger_utils::None</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

</div>
</div>
<a id="a4c5a948d12b8760154eed1281249b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a948d12b8760154eed1281249b0f7">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85192d2ad28e90993950ec5c2598a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85192d2ad28e90993950ec5c2598a3e7">&#9670;&nbsp;</a></span>addAffineForOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addAffineForOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps. </p>
<p>The right identifier is first looked up using <code>forOp</code>'s <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. Asserts if the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the 'affine.for' operation isn't found in the constraint system. Returns failure for the yet unimplemented/unsupported cases. Any new identifiers that are found in the bound operands of the 'affine.for' operation are added as trailing identifiers (either dimensional or symbolic depending on whether the operand is a valid symbol). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00584">584</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00112">mlir::IntegerPolyhedron::addEquality()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l01204">mlir::IntegerPolyhedron::addLocalFloorDiv()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01298">findId()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00140">mlir::IntegerPolyhedron::getNumCols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00636">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00561">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01255">addSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00212">mlir::getIndexSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1b74b3973d5329fe7ec99a7d2f8ed31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">&#9670;&nbsp;</a></span>addAffineIfOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addAffineIfOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints imposed by the <code>affine.if</code> operation. </p>
<p>These constraints are collected from the <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> attached to the given <code>affine.if</code> instance argument (<code>ifOp</code>). It is asserted that: 1) The <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> of the given <code>affine.if</code> instance should not contain semi-affine expressions, 2) The columns of the constraint system created from <code>ifOp</code> should match the columns in the current one regarding numbers and values. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00685">685</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00049">mlir::IntegerPolyhedron::append()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00436">mergeAndAlignIdsWithOther()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00212">mlir::getIndexSet()</a>.</p>

</div>
</div>
<a id="ae0266a236d1adc4c4a08e4d68b741e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0266a236d1adc4c4a08e4d68b741e38">&#9670;&nbsp;</a></span>addBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01231">1231</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00561">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00879">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01203">computeAlignedMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00705">mlir::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00654">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00584">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01321">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00636">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00561">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00193">addLoopRangeConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01255">addSliceBounds()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00103">canonicalizeMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00297">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="a210341fc77fde46aedce6d2609f26738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210341fc77fde46aedce6d2609f26738">&#9670;&nbsp;</a></span>addBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad45db7553a19f068448846a3fe254819">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant bound for the identifier associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01321">1321</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01298">findId()</a>.</p>

</div>
</div>
<a id="a4287995c9f074be38e7e1d76b39d93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4287995c9f074be38e7e1d76b39d93f8">&#9670;&nbsp;</a></span>addDomainFromSliceMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addDomainFromSliceMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice. </p>
<p>Every pair (<code>lbMaps[i]</code>, <code>ubMaps[i]</code>) describes the bounds of a loop in the nest, sorted outer-to-inner. <code>operands</code> contains the bound operands for a single bound map. All the bound maps will use the same bound operands. Note that some loops described by a computation slice might not exist yet in the IR so the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to those dimension identifiers might be empty. For that reason, this method doesn't perform <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> look-ups to retrieve the dimension identifier positions. Instead, it assumes the position of the dim identifiers in the constraint system is the same as the position of the loop in the loop nest. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00636">636</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00584">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01844">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00312">mlir::AffineDimExpr::getPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1150883739ccac33efedf30dd36decfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1150883739ccac33efedf30dd36decfb">&#9670;&nbsp;</a></span>addInductionVarOrTerminalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addInductionVarOrTerminalSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system. </p>
<p><code>val</code> has to be either a terminal symbol or a loop IV, i.e., it cannot be the result affine.apply of any symbols or loop IVs. The identifier is added to the end of the existing dims or symbols. Additional information on the identifier is extracted from the IR and added to the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00561">561</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00584">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00269">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00275">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01310">containsId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01844">mlir::getForInductionVarOwner()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01838">mlir::isForInductionVar()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00233">mlir::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>.</p>

</div>
</div>
<a id="ad38a7dd065a6c286b7ac84f0d1712c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38a7dd065a6c286b7ac84f0d1712c23">&#9670;&nbsp;</a></span>addSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each identifier in the constraint system which has a value in <code>values</code>. </p>
<p>Note that both lower/upper bounds share the same operand list <code>operands</code>. This function assumes <code>values.size</code> == <code>lbMaps.size</code> == <code>ubMaps.size</code>. Note that both lower/upper bounds use operands from <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01255">1255</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00584">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01298">findId()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01844">mlir::getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getResult()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>.</p>

</div>
</div>
<a id="a18111fe7ef555fcb69a9d6a175ea8cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18111fe7ef555fcb69a9d6a175ea8cd8">&#9670;&nbsp;</a></span>appendDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::appendDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append identifiers of the specified kind after the last identifier of that kind. </p>
<p>The coefficient columns corresponding to the added identifiers are initialized to zero. <code>vals</code> are the Values corresponding to the identifiers. Return the position of the first added column.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00269">269</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00291">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00561">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00193">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00103">canonicalizeMinMaxOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00297">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="a2c2a6f8c373783c6b808038d8c07e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a6f8c373783c6b808038d8c07e796">&#9670;&nbsp;</a></span>appendSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::appendSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00275">275</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00133">mlir::IntegerPolyhedron::getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00291">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00561">addInductionVarOrTerminalSymbol()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="a4fb1fae3bb100c4a3391e523712d2dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb1fae3bb100c4a3391e523712d2dba">&#9670;&nbsp;</a></span>areIdsAlignedWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::areIdsAlignedWithOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order. </p>
<p>Calls areIdsAligned to check if two constraint systems have the same set of identifiers in the same order.</p>
<p>Returns false otherwise.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00332">332</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00322">areIdsAligned()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="ae0940692949476995f8facfddffa4f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0940692949476995f8facfddffa4f31">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::FlatAffineValueConstraints::classof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> *&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00249">249</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01155">mlir::FlatAffineConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00149">mlir::FlatAffineConstraints::clone()</a>, <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30a38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::IntegerPolyhedron::FlatAffineValueConstraints</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00097">mlir::IntegerPolyhedron::getKind()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00066">mlir::IntegerPolyhedron::insertDimId()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00078">mlir::IntegerPolyhedron::insertId()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00070">mlir::IntegerPolyhedron::insertSymbolId()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00032">mlir::IntegerPolyhedron::reset()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00194">mlir::IntegerPolyhedron::swapId()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

</div>
</div>
<a id="a536b3f9b979e0c1858e0e8bdf105498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536b3f9b979e0c1858e0e8bdf105498c">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="An extension of FlatAffineConstraints in which dimensions and symbols can optionally be associated wi...">FlatAffineValueConstraints</a> with <code>other</code>. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab862c21c0f836ae88ecb6b39efb68c6b">mlir::FlatAffineConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01359">1359</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1presburger__utils.html#a481b3a20e5591036f0e10ed3c284c964a6adf97f83acf6453d4a6a4b1070f3754">mlir::presburger_utils::None</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

</div>
</div>
<a id="a592860df144ae17907bccf79792e3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592860df144ae17907bccf79792e3f90">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt; FlatAffineValueConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this object. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00154">154</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ad4dd23a785eb9a02c7f2ba43fa1aa7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">&#9670;&nbsp;</a></span>composeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::composeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>vMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map. </p>
<p>Returns failure if the composition fails (when vMap is a semi-affine map). The vMap's operand <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s are used to look up the right positions in the <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> with which to associate. Every operand of vMap should have a matching dim/symbol column in this constraint system (with the same associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00442">442</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00450">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01203">computeAlignedMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a5f1918c91299c463de63c843ee1f7628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1918c91299c463de63c843ee1f7628">&#9670;&nbsp;</a></span>computeAlignedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> FlatAffineValueConstraints::computeAlignedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>map</code> with this constraint system based on <code>operands</code>. </p>
<p>Each operand must already have a corresponding dim/symbol in this constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01203">1203</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01549">mlir::alignAffineMapWithValues()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00508">mlir::IntegerPolyhedron::numDims</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00512">mlir::IntegerPolyhedron::numSymbols</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01231">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00442">composeMap()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a9d547b7f44aaa82af5d5ab1aeb74a42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d547b7f44aaa82af5d5ab1aeb74a42a">&#9670;&nbsp;</a></span>containsId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::containsId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01310">1310</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00561">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a38b004fb4978436d8c8cd8976803468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b004fb4978436d8c8cd8976803468c">&#9670;&nbsp;</a></span>convertLoopIVSymbolsToDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::convertLoopIVSymbolsToDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all symbol identifiers which are loop IVs to dim identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00548">548</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01844">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00134">mlir::IntegerPolyhedron::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00451">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00457">hasValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00499">turnSymbolIntoDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="ab578264c931fe0f78eb0397943d032c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab578264c931fe0f78eb0397943d032c1">&#9670;&nbsp;</a></span>findId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::findId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns true if found (false otherwise). <code>pos</code> is set to the (column) position of the identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01298">1298</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00584">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01321">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01255">addSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00428">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00512">mergeSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01390">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00499">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="a30b3ca6765edfa5677b1b23130e0187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3ca6765edfa5677b1b23130e0187c">&#9670;&nbsp;</a></span>fourierMotzkinEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::fourierMotzkinEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>darkShadow</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isResultIntegerExact</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier. </p>
<p>If the result of the elimination is integer exact, <code>*isResultIntegerExact</code> is set to true. If <code>darkShadow</code> is set to true, a potential under approximation (subset) of the rational shadow / exact integer shadow is computed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a1d8280e304d93ef712a4980bb96b550a">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01377">1377</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l01653">mlir::IntegerPolyhedron::fourierMotzkinEliminate()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00131">mlir::IntegerPolyhedron::getNumIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01390">projectOut()</a>.</p>

</div>
</div>
<a id="af5177b199aa494103835274f72907a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5177b199aa494103835274f72907a8b">&#9670;&nbsp;</a></span>getAllValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::getAllValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00473">473</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="acfee23f39d31078e69df752b973f53b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee23f39d31078e69df752b973f53b6">&#9670;&nbsp;</a></span>getHyperrectangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> FlatAffineValueConstraints::getHyperrectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00206">206</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ac0dbadcb953c32567a17ab1b662505e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dbadcb953c32567a17ab1b662505e0">&#9670;&nbsp;</a></span>getIneqAsAffineValueMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::getIneqAsAffineValueMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>ineqPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bound for the identifier at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands). </p>
<p>The returned affine value map can either be a lower bound or an upper bound depending on the sign of atIneq(ineqPos, pos). Asserts if the row at <code>ineqPos</code> does not involve the <code>pos</code>th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01451">1451</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01421">computeLocalVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00961">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00894">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00160">mlir::IntegerPolyhedron::getInequality()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00140">mlir::IntegerPolyhedron::getNumCols()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00134">mlir::IntegerPolyhedron::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00131">mlir::IntegerPolyhedron::getNumIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00144">mlir::IntegerPolyhedron::getNumInequalities()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00135">mlir::IntegerPolyhedron::getNumLocalIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00133">mlir::IntegerPolyhedron::getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00464">getValues()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00508">mlir::IntegerPolyhedron::numDims</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00019">mlir::AffineValueMap::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>.</p>

</div>
</div>
<a id="ac6234845a4fa3eb9444e56cab0fe5b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30">Kind</a> mlir::FlatAffineValueConstraints::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the kind of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1FlatAffineConstraints.html#abfe3f570757ec45291fc038247cb039b">mlir::FlatAffineConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00247">247</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa08391a9530a1fffa288d92c0bd50a30a38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::IntegerPolyhedron::FlatAffineValueConstraints</a>.</p>

</div>
</div>
<a id="a0d108d7e10610afd56b9bc03598741f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d108d7e10610afd56b9bc03598741f9">&#9670;&nbsp;</a></span>getMaybeDimAndSymbolValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeDimAndSymbolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00489">489</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00133">mlir::IntegerPolyhedron::getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00103">canonicalizeMinMaxOp()</a>.</p>

</div>
</div>
<a id="a1e61e7f65a2ddd3fb4dc389d1fcd4467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61e7f65a2ddd3fb4dc389d1fcd4467">&#9670;&nbsp;</a></span>getMaybeDimValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeDimValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00481">481</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01609">mlir::FlatAffineRelation::compose()</a>.</p>

</div>
</div>
<a id="a464901024f611db773f2def48443b8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464901024f611db773f2def48443b8f8">&#9670;&nbsp;</a></span>getMaybeSymbolValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeSymbolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00485">485</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00133">mlir::IntegerPolyhedron::getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="ad7998d8323c934c13a86769ca8fad877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7998d8323c934c13a86769ca8fad877">&#9670;&nbsp;</a></span>getMaybeValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00477">477</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00322">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00339">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01398">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a3896e7ab007a7bd1e8d1fb1fb098bdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::FlatAffineValueConstraints::getValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> identifier was associated. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00451">451</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01609">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00548">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00428">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00275">getCommonBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00253">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00512">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a9ccc790e216f3bbf7416308c04045094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccc790e216f3bbf7416308c04045094">&#9670;&nbsp;</a></span>getValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::getValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Values associated with identifiers in range [start, end). </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> was associated with one of these identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00464">464</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02653">createSeparationCondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02040">generateCopy()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01451">getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00512">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a3202cddcf31d0798de72cac6742248b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202cddcf31d0798de72cac6742248b0">&#9670;&nbsp;</a></span>hasConsistentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasConsistentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise. </p>
<p>This is meant to be used within an assert internally. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a3b85a47632adfb7c5c15bb2fccdb6492">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00700">700</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00131">mlir::IntegerPolyhedron::getNumIds()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00286">mlir::IntegerPolyhedron::hasConsistentState()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

</div>
</div>
<a id="a5e39afc73e0776e068eb7331bcb349c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e39afc73e0776e068eb7331bcb349c7">&#9670;&nbsp;</a></span>hasValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::FlatAffineValueConstraints::hasValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pos^th identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00457">457</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01609">mlir::FlatAffineRelation::compose()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00548">convertLoopIVSymbolsToDims()</a>.</p>

</div>
</div>
<a id="a321a6a4ea45324a6c969a5b5062ec932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321a6a4ea45324a6c969a5b5062ec932">&#9670;&nbsp;</a></span>hasValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if at least one identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00314">314</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

</div>
</div>
<a id="a37618dd64a6fe91226805818e4139fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37618dd64a6fe91226805818e4139fb9">&#9670;&nbsp;</a></span>insertDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert identifiers of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of identifier. The coefficient columns corresponding to the added identifiers are initialized to zero. <code>vals</code> are the Values corresponding to the identifiers. Return the absolute column position (i.e., not relative to the kind of identifier) of the first added identifier.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00281">281</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00291">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01694">mlir::FlatAffineRelation::appendDomainId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01699">mlir::FlatAffineRelation::appendRangeId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00450">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01680">mlir::FlatAffineRelation::insertDomainId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01687">mlir::FlatAffineRelation::insertRangeId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a7dde72b54f749643d4002efc28a643a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dde72b54f749643d4002efc28a643a0">&#9670;&nbsp;</a></span>insertId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0dca9587b920bc5347b689a2f29695cd">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00291">291</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00269">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00275">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00281">insertDimId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00286">insertSymbolId()</a>.</p>

</div>
</div>
<a id="a5a31a532a6942ad1f960d6663ab8fede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a31a532a6942ad1f960d6663ab8fede">&#9670;&nbsp;</a></span>insertId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00299">299</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="a99c6ee75c0627beaeb455d0428636849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c6ee75c0627beaeb455d0428636849">&#9670;&nbsp;</a></span>insertSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00286">286</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00291">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00512">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="ad2eed02898a13f56e0bc2a470c2f89af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eed02898a13f56e0bc2a470c2f89af">&#9670;&nbsp;</a></span>mergeAndAlignIdsWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::mergeAndAlignIdsWithOther </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align the identifiers of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with <code>this</code>'s original identifiers appearing first followed by any of <code>other</code>'s identifiers that didn't appear in <code>this</code>. </p>
<p>Local identifiers in <code>other</code> that have the same division representation as local identifiers in <code>this</code> are merged into one. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00436">436</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00685">addAffineIfOpDomain()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a5333879b7e111caf2c3371c0d0745296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5333879b7e111caf2c3371c0d0745296">&#9670;&nbsp;</a></span>mergeSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::mergeSymbolIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique. </p>
<p>Symbols in <code>this</code> and <code>other</code> should be unique. Symbols with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> as <code>None</code> are considered to be inequal to all other symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00512">512</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00339">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01298">findId()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00134">mlir::IntegerPolyhedron::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00133">mlir::IntegerPolyhedron::getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00451">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00464">getValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">insertSymbolId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01316">swapId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01609">mlir::FlatAffineRelation::compose()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a79575e2c2693576f2c5a4accf0dcdab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79575e2c2693576f2c5a4accf0dcdab6">&#9670;&nbsp;</a></span>projectOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01390">1390</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01298">findId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01377">fourierMotzkinEliminate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>.</p>

</div>
</div>
<a id="a2b415d11d42c0a1e02bc2c35833d3a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b415d11d42c0a1e02bc2c35833d3a2d">&#9670;&nbsp;</a></span>removeIdRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::removeIdRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0b9f60a450b02d29b4cc693f730dc780">mlir::IntegerPolyhedron</a>.</p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineRelation.html#a1d7c7d7e81a2975456aca816950b0f0c">mlir::FlatAffineRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00705">705</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00132">mlir::IntegerPolyhedron::removeIdRange()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01665">mlir::FlatAffineRelation::inverse()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01704">mlir::FlatAffineRelation::removeIdRange()</a>.</p>

</div>
</div>
<a id="ad9813ab39fe84ac3208f6475c0058e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9813ab39fe84ac3208f6475c0058e02">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears any existing data and reserves memory for the specified constraints. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aade68321941df8db9b3ec9dc97f1ffbb">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00236">236</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00366">checkTilingLegalityImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00212">mlir::getIndexSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00261">reset()</a>.</p>

</div>
</div>
<a id="a58e00fa2f257f1bd2c8ab11369207198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00fa2f257f1bd2c8ab11369207198">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00246">246</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00184">FlatAffineValueConstraints()</a>.</p>

</div>
</div>
<a id="ae3a94ce5a825b81e5767fef38db2329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a94ce5a825b81e5767fef38db2329a">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00261">261</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00236">reset()</a>.</p>

</div>
</div>
<a id="a5eccad1d331cf5cfb78bf1f08fda7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eccad1d331cf5cfb78bf1f08fda7224">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00494">494</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01609">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00428">mlir::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01759">mlir::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a320c65d604a6089bb16894e4a9ee33bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c65d604a6089bb16894e4a9ee33bf">&#9670;&nbsp;</a></span>setValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::setValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Values associated with the identifiers in the range [start, end). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00500">500</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l01653">mlir::IntegerPolyhedron::fourierMotzkinEliminate()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00286">mlir::IntegerPolyhedron::hasConsistentState()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00505">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00132">mlir::IntegerPolyhedron::removeIdRange()</a>.</p>

</div>
</div>
<a id="acda87dfc4340eb857e9bc9ab05141b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda87dfc4340eb857e9bc9ab05141b16">&#9670;&nbsp;</a></span>swapId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::swapId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the posA^th identifier with the posB^th identifier. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa591bcb71980075a8e8aea52bc0df0cc">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01316">1316</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00194">mlir::IntegerPolyhedron::swapId()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00539">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00428">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01665">mlir::FlatAffineRelation::inverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00512">mergeSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00499">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="af0c35f1d2d81adf4ba06b84df578cd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c35f1d2d81adf4ba06b84df578cd78">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially. </p>
<p>For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. <code>other</code> is expected to have the same dimensional identifiers as this constraint system (in the same order).</p>
<p>E.g.: 1) this = {0 &lt;= d0 &lt;= 127}, other = {16 &lt;= d0 &lt;= 192}, output = {0 &lt;= d0 &lt;= 192} 2) this = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, other = {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20} 3) this = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9} other = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15} </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01398">1398</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00322">areIdsAligned()</a>, <a class="el" href="AffineStructures_8h_source.html#l00477">getMaybeValues()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00132">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00135">mlir::IntegerPolyhedron::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00386">mergeAndAlignIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00508">mlir::IntegerPolyhedron::numDims</a>, and <a class="el" href="IntegerPolyhedron_8cpp_source.html#l01899">mlir::IntegerPolyhedron::unionBoundingBox()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2662045a8d845c7cf9aa9516af6ea914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2662045a8d845c7cf9aa9516af6ea914">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;, 8&gt; mlir::FlatAffineValueConstraints::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values corresponding to the (column) identifiers of this constraint system appearing in the order the identifiers correspond to columns. </p>
<p>Temporary ones or those that aren't associated with any <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> are set to None. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00539">539</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01359">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01609">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01203">computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01310">containsId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01298">findId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00189">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01377">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00700">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00314">hasValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00705">removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01316">swapId()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 26 2022 20:34:18 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
